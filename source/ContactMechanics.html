<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ContactMechanics package &mdash; ContactMechanics 1.4.0.dev9+g68e461b9 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=9d3f3d97"></script>
        <script src="../_static/doctools.js?v=9a2dae69"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ContactMechanics.CommandLineInterface package" href="ContactMechanics.CommandLineInterface.html" />
    <link rel="prev" title="Contributing to ContactMechanics" href="../contributing.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            ContactMechanics
          </a>
              <div class="version">
                1.4.0.dev9+g68e461b9
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../testing.html">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../testing.html#linter">Linter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing to ContactMechanics</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Package Reference</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">ContactMechanics package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.CommandLineInterface.html">ContactMechanics.CommandLineInterface package</a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.GreensFunctions.html">ContactMechanics.GreensFunctions package</a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.IO.html">ContactMechanics.IO package</a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.Optimization.html">ContactMechanics.Optimization package</a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html">ContactMechanics.ReferenceSolutions package</a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.Tools.html">ContactMechanics.Tools package</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-ContactMechanics.FFTElasticHalfSpace">ContactMechanics.FFTElasticHalfSpace module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#convention-used-for-the-dft">Convention used for the DFT :</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parseval-s-theorem-convolutions-and-powers">Parseval’s theorem, Convolutions and powers:</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mufft-fourier-transform">muFFT fourier transform:</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mufft-vs-np-fft">muFFT vs. np.fft:</a></li>
<li class="toctree-l3"><a class="reference internal" href="#normalisation">Normalisation:</a></li>
<li class="toctree-l3"><a class="reference internal" href="#d-fft">2D FFT:</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.BndSet"><code class="docutils literal notranslate"><span class="pre">BndSet</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.BndSet.large"><code class="docutils literal notranslate"><span class="pre">BndSet.large</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.BndSet.small"><code class="docutils literal notranslate"><span class="pre">BndSet.small</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace"><code class="docutils literal notranslate"><span class="pre">FreeFFTElasticHalfSpace</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.FreeBoundaryError"><code class="docutils literal notranslate"><span class="pre">FreeFFTElasticHalfSpace.FreeBoundaryError</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.check"><code class="docutils literal notranslate"><span class="pre">FreeFFTElasticHalfSpace.check()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.check_boundaries"><code class="docutils literal notranslate"><span class="pre">FreeFFTElasticHalfSpace.check_boundaries()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.domain_boundary_mask"><code class="docutils literal notranslate"><span class="pre">FreeFFTElasticHalfSpace.domain_boundary_mask</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.evaluate_disp"><code class="docutils literal notranslate"><span class="pre">FreeFFTElasticHalfSpace.evaluate_disp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.name"><code class="docutils literal notranslate"><span class="pre">FreeFFTElasticHalfSpace.name</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.nb_domain_grid_pts"><code class="docutils literal notranslate"><span class="pre">FreeFFTElasticHalfSpace.nb_domain_grid_pts</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.spawn_child"><code class="docutils literal notranslate"><span class="pre">FreeFFTElasticHalfSpace.spawn_child()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.topography_nb_subdomain_grid_pts"><code class="docutils literal notranslate"><span class="pre">FreeFFTElasticHalfSpace.topography_nb_subdomain_grid_pts</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.area_per_pt"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.area_per_pt</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.communicator"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.communicator</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.dim"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.dim</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.evaluate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_disp"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.evaluate_disp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_elastic_energy"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.evaluate_elastic_energy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_elastic_energy_k_space"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.evaluate_elastic_energy_k_space()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_force"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.evaluate_force()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_k"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.evaluate_k()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_k_disp"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.evaluate_k_disp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_k_force"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.evaluate_k_force()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_k_force_k"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.evaluate_k_force_k()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_scalar_product_k_space"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.evaluate_scalar_product_k_space()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.fourier_locations"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.fourier_locations</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.fourier_slices"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.fourier_slices</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.local_topography_subdomain_slices"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.local_topography_subdomain_slices</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.name"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.name</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.nb_domain_grid_pts"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.nb_domain_grid_pts</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.nb_fourier_grid_pts"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.nb_fourier_grid_pts</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.nb_grid_pts"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.nb_grid_pts</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.nb_subdomain_grid_pts"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.nb_subdomain_grid_pts</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.physical_sizes"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.physical_sizes</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.subdomain_locations"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.subdomain_locations</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.subdomain_slices"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.subdomain_slices</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.topography_nb_subdomain_grid_pts"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.topography_nb_subdomain_grid_pts</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.topography_subdomain_locations"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.topography_subdomain_locations</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.topography_subdomain_slices"><code class="docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace.topography_subdomain_slices</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-ContactMechanics.Factory">ContactMechanics.Factory module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ContactMechanics.Factory.make_contact_system"><code class="docutils literal notranslate"><span class="pre">make_contact_system()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ContactMechanics.Factory.make_plastic_contact_system"><code class="docutils literal notranslate"><span class="pre">make_plastic_contact_system()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ContactMechanics.Factory.make_plastic_system"><code class="docutils literal notranslate"><span class="pre">make_plastic_system()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ContactMechanics.Factory.make_system"><code class="docutils literal notranslate"><span class="pre">make_system()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-ContactMechanics.PipelineFunction">ContactMechanics.PipelineFunction module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ContactMechanics.PipelineFunction.contact_mechanics"><code class="docutils literal notranslate"><span class="pre">contact_mechanics()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-ContactMechanics.PlasticSystemSpecialisations">ContactMechanics.PlasticSystemSpecialisations module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ContactMechanics.PlasticSystemSpecialisations.PlasticNonSmoothContactSystem"><code class="docutils literal notranslate"><span class="pre">PlasticNonSmoothContactSystem</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.PlasticSystemSpecialisations.PlasticNonSmoothContactSystem.handles"><code class="docutils literal notranslate"><span class="pre">PlasticNonSmoothContactSystem.handles()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.PlasticSystemSpecialisations.PlasticNonSmoothContactSystem.minimize_proxy"><code class="docutils literal notranslate"><span class="pre">PlasticNonSmoothContactSystem.minimize_proxy()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-ContactMechanics.Substrates">ContactMechanics.Substrates module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ContactMechanics.Substrates.ElasticSubstrate"><code class="docutils literal notranslate"><span class="pre">ElasticSubstrate</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Substrates.ElasticSubstrate.compute"><code class="docutils literal notranslate"><span class="pre">ElasticSubstrate.compute()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Substrates.ElasticSubstrate.compute_k"><code class="docutils literal notranslate"><span class="pre">ElasticSubstrate.compute_k()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Substrates.ElasticSubstrate.evaluate"><code class="docutils literal notranslate"><span class="pre">ElasticSubstrate.evaluate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Substrates.ElasticSubstrate.name"><code class="docutils literal notranslate"><span class="pre">ElasticSubstrate.name</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ContactMechanics.Substrates.PlasticSubstrate"><code class="docutils literal notranslate"><span class="pre">PlasticSubstrate</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Substrates.PlasticSubstrate.name"><code class="docutils literal notranslate"><span class="pre">PlasticSubstrate.name</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ContactMechanics.Substrates.Substrate"><code class="docutils literal notranslate"><span class="pre">Substrate</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Substrates.Substrate.Error"><code class="docutils literal notranslate"><span class="pre">Substrate.Error</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Substrates.Substrate.check"><code class="docutils literal notranslate"><span class="pre">Substrate.check()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Substrates.Substrate.communicator"><code class="docutils literal notranslate"><span class="pre">Substrate.communicator</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Substrates.Substrate.is_periodic"><code class="docutils literal notranslate"><span class="pre">Substrate.is_periodic()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Substrates.Substrate.name"><code class="docutils literal notranslate"><span class="pre">Substrate.name</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Substrates.Substrate.nb_domain_grid_pts"><code class="docutils literal notranslate"><span class="pre">Substrate.nb_domain_grid_pts</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Substrates.Substrate.nb_subdomain_grid_pts"><code class="docutils literal notranslate"><span class="pre">Substrate.nb_subdomain_grid_pts</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Substrates.Substrate.spawn_child"><code class="docutils literal notranslate"><span class="pre">Substrate.spawn_child()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Substrates.Substrate.subdomain_locations"><code class="docutils literal notranslate"><span class="pre">Substrate.subdomain_locations</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-ContactMechanics.Systems">ContactMechanics.Systems module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ContactMechanics.Systems.IncompatibleFormulationError"><code class="docutils literal notranslate"><span class="pre">IncompatibleFormulationError</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ContactMechanics.Systems.IncompatibleResolutionError"><code class="docutils literal notranslate"><span class="pre">IncompatibleResolutionError</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem"><code class="docutils literal notranslate"><span class="pre">NonSmoothContactSystem</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.compute_contact_coordinates"><code class="docutils literal notranslate"><span class="pre">NonSmoothContactSystem.compute_contact_coordinates()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.compute_nb_contact_pts"><code class="docutils literal notranslate"><span class="pre">NonSmoothContactSystem.compute_nb_contact_pts()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.compute_normal_force"><code class="docutils literal notranslate"><span class="pre">NonSmoothContactSystem.compute_normal_force()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.dual_hessian_product"><code class="docutils literal notranslate"><span class="pre">NonSmoothContactSystem.dual_hessian_product()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.dual_minimize_proxy"><code class="docutils literal notranslate"><span class="pre">NonSmoothContactSystem.dual_minimize_proxy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.dual_objective"><code class="docutils literal notranslate"><span class="pre">NonSmoothContactSystem.dual_objective()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.evaluate"><code class="docutils literal notranslate"><span class="pre">NonSmoothContactSystem.evaluate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.evaluate_dual"><code class="docutils literal notranslate"><span class="pre">NonSmoothContactSystem.evaluate_dual()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.handles"><code class="docutils literal notranslate"><span class="pre">NonSmoothContactSystem.handles()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.hessian_product"><code class="docutils literal notranslate"><span class="pre">NonSmoothContactSystem.hessian_product()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.logger_input"><code class="docutils literal notranslate"><span class="pre">NonSmoothContactSystem.logger_input()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.minimize_proxy"><code class="docutils literal notranslate"><span class="pre">NonSmoothContactSystem.minimize_proxy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.nb_grid_pts"><code class="docutils literal notranslate"><span class="pre">NonSmoothContactSystem.nb_grid_pts</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.objective"><code class="docutils literal notranslate"><span class="pre">NonSmoothContactSystem.objective()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.primal_hessian_product"><code class="docutils literal notranslate"><span class="pre">NonSmoothContactSystem.primal_hessian_product()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.primal_minimize_proxy"><code class="docutils literal notranslate"><span class="pre">NonSmoothContactSystem.primal_minimize_proxy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.primal_objective"><code class="docutils literal notranslate"><span class="pre">NonSmoothContactSystem.primal_objective()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ContactMechanics.Systems.SystemBase"><code class="docutils literal notranslate"><span class="pre">SystemBase</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.callback"><code class="docutils literal notranslate"><span class="pre">SystemBase.callback()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.compute_contact_area"><code class="docutils literal notranslate"><span class="pre">SystemBase.compute_contact_area()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.compute_gap"><code class="docutils literal notranslate"><span class="pre">SystemBase.compute_gap()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.compute_nb_contact_pts"><code class="docutils literal notranslate"><span class="pre">SystemBase.compute_nb_contact_pts()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.compute_normal_force"><code class="docutils literal notranslate"><span class="pre">SystemBase.compute_normal_force()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.compute_relative_contact_area"><code class="docutils literal notranslate"><span class="pre">SystemBase.compute_relative_contact_area()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.evaluate"><code class="docutils literal notranslate"><span class="pre">SystemBase.evaluate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.handles"><code class="docutils literal notranslate"><span class="pre">SystemBase.handles()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.is_proxy"><code class="docutils literal notranslate"><span class="pre">SystemBase.is_proxy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.minimize_proxy"><code class="docutils literal notranslate"><span class="pre">SystemBase.minimize_proxy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.nb_grid_pts"><code class="docutils literal notranslate"><span class="pre">SystemBase.nb_grid_pts</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.objective"><code class="docutils literal notranslate"><span class="pre">SystemBase.objective()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.shape_minimisation_input"><code class="docutils literal notranslate"><span class="pre">SystemBase.shape_minimisation_input()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.shape_minimisation_output"><code class="docutils literal notranslate"><span class="pre">SystemBase.shape_minimisation_output()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#contactmechanics-test-surface-topography-module">ContactMechanics.test_surface_topography module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-ContactMechanics">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ContactMechanics.GreensFunctions.html">ContactMechanics.GreensFunctions package</a></li>
<li class="toctree-l1"><a class="reference internal" href="ContactMechanics.IO.html">ContactMechanics.IO package</a></li>
<li class="toctree-l1"><a class="reference internal" href="ContactMechanics.Optimization.html">ContactMechanics.Optimization package</a></li>
<li class="toctree-l1"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html">ContactMechanics.ReferenceSolutions package</a></li>
<li class="toctree-l1"><a class="reference internal" href="ContactMechanics.Tools.html">ContactMechanics.Tools package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">ContactMechanics</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">ContactMechanics package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/source/ContactMechanics.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="contactmechanics-package">
<h1>ContactMechanics package<a class="headerlink" href="#contactmechanics-package" title="Link to this heading"></a></h1>
<section id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Link to this heading"></a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="ContactMechanics.CommandLineInterface.html">ContactMechanics.CommandLineInterface package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ContactMechanics.CommandLineInterface.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="ContactMechanics.CommandLineInterface.html#module-ContactMechanics.CommandLineInterface.HardWall">ContactMechanics.CommandLineInterface.HardWall module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.CommandLineInterface.html#ContactMechanics.CommandLineInterface.HardWall.dump"><code class="docutils literal notranslate"><span class="pre">dump()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.CommandLineInterface.html#ContactMechanics.CommandLineInterface.HardWall.dump_nc"><code class="docutils literal notranslate"><span class="pre">dump_nc()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.CommandLineInterface.html#ContactMechanics.CommandLineInterface.HardWall.main"><code class="docutils literal notranslate"><span class="pre">main()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.CommandLineInterface.html#ContactMechanics.CommandLineInterface.HardWall.next_step"><code class="docutils literal notranslate"><span class="pre">next_step()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.CommandLineInterface.html#ContactMechanics.CommandLineInterface.HardWall.save_contact"><code class="docutils literal notranslate"><span class="pre">save_contact()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.CommandLineInterface.html#ContactMechanics.CommandLineInterface.HardWall.save_gap"><code class="docutils literal notranslate"><span class="pre">save_gap()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.CommandLineInterface.html#ContactMechanics.CommandLineInterface.HardWall.save_pressure"><code class="docutils literal notranslate"><span class="pre">save_pressure()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.CommandLineInterface.html#ContactMechanics.CommandLineInterface.HardWall.tuple2"><code class="docutils literal notranslate"><span class="pre">tuple2()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ContactMechanics.CommandLineInterface.html#module-ContactMechanics.CommandLineInterface">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ContactMechanics.GreensFunctions.html">ContactMechanics.GreensFunctions package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ContactMechanics.GreensFunctions.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="ContactMechanics.GreensFunctions.html#module-ContactMechanics.GreensFunctions.Anisotropic">ContactMechanics.GreensFunctions.Anisotropic module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.GreensFunctions.html#ContactMechanics.GreensFunctions.Anisotropic.AnisotropicGreensFunction"><code class="docutils literal notranslate"><span class="pre">AnisotropicGreensFunction</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.GreensFunctions.html#ContactMechanics.GreensFunctions.Anisotropic.AnisotropicGreensFunction.bulkop"><code class="docutils literal notranslate"><span class="pre">AnisotropicGreensFunction.bulkop()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.GreensFunctions.html#ContactMechanics.GreensFunctions.Anisotropic.AnisotropicGreensFunction.elasticity_tensor"><code class="docutils literal notranslate"><span class="pre">AnisotropicGreensFunction.elasticity_tensor()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.GreensFunctions.html#ContactMechanics.GreensFunctions.Anisotropic.AnisotropicGreensFunction.find_eigenvalues"><code class="docutils literal notranslate"><span class="pre">AnisotropicGreensFunction.find_eigenvalues()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.GreensFunctions.html#ContactMechanics.GreensFunctions.Anisotropic.AnisotropicGreensFunction.find_eigenvectors"><code class="docutils literal notranslate"><span class="pre">AnisotropicGreensFunction.find_eigenvectors()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.GreensFunctions.html#ContactMechanics.GreensFunctions.Anisotropic.AnisotropicGreensFunction.greens_function"><code class="docutils literal notranslate"><span class="pre">AnisotropicGreensFunction.greens_function()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.GreensFunctions.html#ContactMechanics.GreensFunctions.Anisotropic.AnisotropicGreensFunction.stiffness"><code class="docutils literal notranslate"><span class="pre">AnisotropicGreensFunction.stiffness()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.GreensFunctions.html#ContactMechanics.GreensFunctions.Anisotropic.AnisotropicGreensFunction.voigt_from_tensor"><code class="docutils literal notranslate"><span class="pre">AnisotropicGreensFunction.voigt_from_tensor()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ContactMechanics.GreensFunctions.html#module-ContactMechanics.GreensFunctions.Isotropic">ContactMechanics.GreensFunctions.Isotropic module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.GreensFunctions.html#ContactMechanics.GreensFunctions.Isotropic.IsotropicGreensFunction"><code class="docutils literal notranslate"><span class="pre">IsotropicGreensFunction</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.GreensFunctions.html#ContactMechanics.GreensFunctions.Isotropic.IsotropicGreensFunction.greens_function"><code class="docutils literal notranslate"><span class="pre">IsotropicGreensFunction.greens_function()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.GreensFunctions.html#ContactMechanics.GreensFunctions.Isotropic.IsotropicGreensFunction.stiffness"><code class="docutils literal notranslate"><span class="pre">IsotropicGreensFunction.stiffness()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ContactMechanics.GreensFunctions.html#module-ContactMechanics.GreensFunctions">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ContactMechanics.IO.html">ContactMechanics.IO package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ContactMechanics.IO.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="ContactMechanics.IO.html#module-ContactMechanics.IO.NetCDF">ContactMechanics.IO.NetCDF module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.IO.html#ContactMechanics.IO.NetCDF.NetCDFContainer"><code class="docutils literal notranslate"><span class="pre">NetCDFContainer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.IO.html#ContactMechanics.IO.NetCDF.NetCDFContainer.close"><code class="docutils literal notranslate"><span class="pre">NetCDFContainer.close()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.IO.html#ContactMechanics.IO.NetCDF.NetCDFContainer.get_cursor"><code class="docutils literal notranslate"><span class="pre">NetCDFContainer.get_cursor()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.IO.html#ContactMechanics.IO.NetCDF.NetCDFContainer.get_elastic_surface"><code class="docutils literal notranslate"><span class="pre">NetCDFContainer.get_elastic_surface()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.IO.html#ContactMechanics.IO.NetCDF.NetCDFContainer.get_filename"><code class="docutils literal notranslate"><span class="pre">NetCDFContainer.get_filename()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.IO.html#ContactMechanics.IO.NetCDF.NetCDFContainer.get_h"><code class="docutils literal notranslate"><span class="pre">NetCDFContainer.get_h()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.IO.html#ContactMechanics.IO.NetCDF.NetCDFContainer.get_next_frame"><code class="docutils literal notranslate"><span class="pre">NetCDFContainer.get_next_frame()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.IO.html#ContactMechanics.IO.NetCDF.NetCDFContainer.get_rigid_surface"><code class="docutils literal notranslate"><span class="pre">NetCDFContainer.get_rigid_surface()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.IO.html#ContactMechanics.IO.NetCDF.NetCDFContainer.get_size"><code class="docutils literal notranslate"><span class="pre">NetCDFContainer.get_size()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.IO.html#ContactMechanics.IO.NetCDF.NetCDFContainer.has_h"><code class="docutils literal notranslate"><span class="pre">NetCDFContainer.has_h()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.IO.html#ContactMechanics.IO.NetCDF.NetCDFContainer.set_cursor"><code class="docutils literal notranslate"><span class="pre">NetCDFContainer.set_cursor()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.IO.html#ContactMechanics.IO.NetCDF.NetCDFContainer.set_elastic_surface"><code class="docutils literal notranslate"><span class="pre">NetCDFContainer.set_elastic_surface()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.IO.html#ContactMechanics.IO.NetCDF.NetCDFContainer.set_h"><code class="docutils literal notranslate"><span class="pre">NetCDFContainer.set_h()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.IO.html#ContactMechanics.IO.NetCDF.NetCDFContainer.set_rigid_surface"><code class="docutils literal notranslate"><span class="pre">NetCDFContainer.set_rigid_surface()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.IO.html#ContactMechanics.IO.NetCDF.NetCDFContainer.set_shape"><code class="docutils literal notranslate"><span class="pre">NetCDFContainer.set_shape()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.IO.html#ContactMechanics.IO.NetCDF.NetCDFContainer.sync"><code class="docutils literal notranslate"><span class="pre">NetCDFContainer.sync()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.IO.html#ContactMechanics.IO.NetCDF.NetCDFContainerFrame"><code class="docutils literal notranslate"><span class="pre">NetCDFContainerFrame</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.IO.html#ContactMechanics.IO.NetCDF.NetCDFContainerFrame.get_index"><code class="docutils literal notranslate"><span class="pre">NetCDFContainerFrame.get_index()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.IO.html#ContactMechanics.IO.NetCDF.NetCDFContainerFrame.get_traj"><code class="docutils literal notranslate"><span class="pre">NetCDFContainerFrame.get_traj()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.IO.html#ContactMechanics.IO.NetCDF.NetCDFContainerFrame.index"><code class="docutils literal notranslate"><span class="pre">NetCDFContainerFrame.index</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.IO.html#ContactMechanics.IO.NetCDF.NetCDFContainerFrame.set_grid"><code class="docutils literal notranslate"><span class="pre">NetCDFContainerFrame.set_grid()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.IO.html#ContactMechanics.IO.NetCDF.NetCDFContainerFrame.sync"><code class="docutils literal notranslate"><span class="pre">NetCDFContainerFrame.sync()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.IO.html#ContactMechanics.IO.NetCDF.NetCDFContainerFrame.traj"><code class="docutils literal notranslate"><span class="pre">NetCDFContainerFrame.traj</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.IO.html#ContactMechanics.IO.NetCDF.open"><code class="docutils literal notranslate"><span class="pre">open()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ContactMechanics.IO.html#module-ContactMechanics.IO">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ContactMechanics.Optimization.html">ContactMechanics.Optimization package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ContactMechanics.Optimization.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="ContactMechanics.Optimization.html#module-ContactMechanics.Optimization.ConstrainedConjugateGradients">ContactMechanics.Optimization.ConstrainedConjugateGradients module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ContactMechanics.Optimization.html#module-ContactMechanics.Optimization">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html">ContactMechanics.ReferenceSolutions package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#module-ContactMechanics.ReferenceSolutions.Cone">ContactMechanics.ReferenceSolutions.Cone module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#ContactMechanics.ReferenceSolutions.Cone.contact_radius_and_area"><code class="docutils literal notranslate"><span class="pre">contact_radius_and_area()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#ContactMechanics.ReferenceSolutions.Cone.deformation"><code class="docutils literal notranslate"><span class="pre">deformation()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#ContactMechanics.ReferenceSolutions.Cone.load_and_mean_pressure"><code class="docutils literal notranslate"><span class="pre">load_and_mean_pressure()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#ContactMechanics.ReferenceSolutions.Cone.pressure"><code class="docutils literal notranslate"><span class="pre">pressure()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#module-ContactMechanics.ReferenceSolutions.GreenwoodTripp">ContactMechanics.ReferenceSolutions.GreenwoodTripp module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#ContactMechanics.ReferenceSolutions.GreenwoodTripp.Fn"><code class="docutils literal notranslate"><span class="pre">Fn()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#ContactMechanics.ReferenceSolutions.GreenwoodTripp.GreenwoodTripp"><code class="docutils literal notranslate"><span class="pre">GreenwoodTripp()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#ContactMechanics.ReferenceSolutions.GreenwoodTripp.s"><code class="docutils literal notranslate"><span class="pre">s()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#ContactMechanics.ReferenceSolutions.GreenwoodTripp."><code class="docutils literal notranslate"><span class="pre">ξ()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#module-ContactMechanics.ReferenceSolutions.Hertz">ContactMechanics.ReferenceSolutions.Hertz module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#ContactMechanics.ReferenceSolutions.Hertz.centerline_stress"><code class="docutils literal notranslate"><span class="pre">centerline_stress()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#ContactMechanics.ReferenceSolutions.Hertz.elastic_energy"><code class="docutils literal notranslate"><span class="pre">elastic_energy()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#ContactMechanics.ReferenceSolutions.Hertz.max_pressure__penetration"><code class="docutils literal notranslate"><span class="pre">max_pressure__penetration()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#ContactMechanics.ReferenceSolutions.Hertz.normal_load"><code class="docutils literal notranslate"><span class="pre">normal_load()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#ContactMechanics.ReferenceSolutions.Hertz.penetration"><code class="docutils literal notranslate"><span class="pre">penetration()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#ContactMechanics.ReferenceSolutions.Hertz.radius_and_pressure"><code class="docutils literal notranslate"><span class="pre">radius_and_pressure()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#ContactMechanics.ReferenceSolutions.Hertz.stress"><code class="docutils literal notranslate"><span class="pre">stress()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#ContactMechanics.ReferenceSolutions.Hertz.stress_Cartesian"><code class="docutils literal notranslate"><span class="pre">stress_Cartesian()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#ContactMechanics.ReferenceSolutions.Hertz.stress_for_tangential_loading"><code class="docutils literal notranslate"><span class="pre">stress_for_tangential_loading()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#ContactMechanics.ReferenceSolutions.Hertz.surface_displacements"><code class="docutils literal notranslate"><span class="pre">surface_displacements()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#ContactMechanics.ReferenceSolutions.Hertz.surface_stress"><code class="docutils literal notranslate"><span class="pre">surface_stress()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#module-ContactMechanics.ReferenceSolutions.Westergaard">ContactMechanics.ReferenceSolutions.Westergaard module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#nommenclature">Nommenclature:</a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#ContactMechanics.ReferenceSolutions.Westergaard.contact_radius"><code class="docutils literal notranslate"><span class="pre">contact_radius()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#ContactMechanics.ReferenceSolutions.Westergaard.displacements"><code class="docutils literal notranslate"><span class="pre">displacements()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#ContactMechanics.ReferenceSolutions.Westergaard.elastic_energy"><code class="docutils literal notranslate"><span class="pre">elastic_energy()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#ContactMechanics.ReferenceSolutions.Westergaard.elastic_energy_a"><code class="docutils literal notranslate"><span class="pre">elastic_energy_a()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#ContactMechanics.ReferenceSolutions.Westergaard.gap"><code class="docutils literal notranslate"><span class="pre">gap()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#ContactMechanics.ReferenceSolutions.Westergaard.mean_displacement"><code class="docutils literal notranslate"><span class="pre">mean_displacement()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#ContactMechanics.ReferenceSolutions.Westergaard.mean_pressure"><code class="docutils literal notranslate"><span class="pre">mean_pressure()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ContactMechanics.ReferenceSolutions.html#module-ContactMechanics.ReferenceSolutions">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ContactMechanics.Tools.html">ContactMechanics.Tools package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ContactMechanics.Tools.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="ContactMechanics.Tools.html#module-ContactMechanics.Tools.Logger">ContactMechanics.Tools.Logger module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.Tools.html#ContactMechanics.Tools.Logger.Logger"><code class="docutils literal notranslate"><span class="pre">Logger</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.Tools.html#ContactMechanics.Tools.Logger.Logger.flush"><code class="docutils literal notranslate"><span class="pre">Logger.flush()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.Tools.html#ContactMechanics.Tools.Logger.Logger.get_logfile"><code class="docutils literal notranslate"><span class="pre">Logger.get_logfile()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.Tools.html#ContactMechanics.Tools.Logger.Logger.has_logfile"><code class="docutils literal notranslate"><span class="pre">Logger.has_logfile()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.Tools.html#ContactMechanics.Tools.Logger.Logger.iteration_finished"><code class="docutils literal notranslate"><span class="pre">Logger.iteration_finished()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.Tools.html#ContactMechanics.Tools.Logger.Logger.pr"><code class="docutils literal notranslate"><span class="pre">Logger.pr()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.Tools.html#ContactMechanics.Tools.Logger.Logger.set_logfile"><code class="docutils literal notranslate"><span class="pre">Logger.set_logfile()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.Tools.html#ContactMechanics.Tools.Logger.Logger.set_outevery"><code class="docutils literal notranslate"><span class="pre">Logger.set_outevery()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.Tools.html#ContactMechanics.Tools.Logger.Logger.st"><code class="docutils literal notranslate"><span class="pre">Logger.st()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="ContactMechanics.Tools.html#ContactMechanics.Tools.Logger.Logger.warn"><code class="docutils literal notranslate"><span class="pre">Logger.warn()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.Tools.html#ContactMechanics.Tools.Logger.flatten"><code class="docutils literal notranslate"><span class="pre">flatten()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.Tools.html#ContactMechanics.Tools.Logger.hdr_str"><code class="docutils literal notranslate"><span class="pre">hdr_str()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.Tools.html#ContactMechanics.Tools.Logger.hdrfmt_str"><code class="docutils literal notranslate"><span class="pre">hdrfmt_str()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.Tools.html#ContactMechanics.Tools.Logger.numfmt_str"><code class="docutils literal notranslate"><span class="pre">numfmt_str()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ContactMechanics.Tools.html#module-ContactMechanics.Tools.common">ContactMechanics.Tools.common module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.Tools.html#ContactMechanics.Tools.common.compare_containers"><code class="docutils literal notranslate"><span class="pre">compare_containers()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.Tools.html#ContactMechanics.Tools.common.compute_wavevectors"><code class="docutils literal notranslate"><span class="pre">compute_wavevectors()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.Tools.html#ContactMechanics.Tools.common.evaluate_gradient"><code class="docutils literal notranslate"><span class="pre">evaluate_gradient()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.Tools.html#ContactMechanics.Tools.common.fftn"><code class="docutils literal notranslate"><span class="pre">fftn()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.Tools.html#ContactMechanics.Tools.common.get_q_from_lambda"><code class="docutils literal notranslate"><span class="pre">get_q_from_lambda()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.Tools.html#ContactMechanics.Tools.common.ifftn"><code class="docutils literal notranslate"><span class="pre">ifftn()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="ContactMechanics.Tools.html#ContactMechanics.Tools.common.mean_err"><code class="docutils literal notranslate"><span class="pre">mean_err()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ContactMechanics.Tools.html#module-ContactMechanics.Tools">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</section>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading"></a></h2>
</section>
<section id="module-ContactMechanics.FFTElasticHalfSpace">
<span id="contactmechanics-fftelastichalfspace-module"></span><h2>ContactMechanics.FFTElasticHalfSpace module<a class="headerlink" href="#module-ContactMechanics.FFTElasticHalfSpace" title="Link to this heading"></a></h2>
<p>Implement the FFT-based elasticity solver of ContactMechanics</p>
<section id="convention-used-for-the-dft">
<h3>Convention used for the DFT :<a class="headerlink" href="#convention-used-for-the-dft" title="Link to this heading"></a></h3>
<p>In addition to the sum of the product with the exponential function, the
one has to divide by <span class="math notranslate nohighlight">\(n_x n_y\)</span> once during the roundtrip.</p>
<p>When this is actually done is arbitrary.</p>
<p>Our convension:</p>
<p>fourier transform:</p>
<div class="math notranslate nohighlight">
\[\tilde h_{op} =
\sum_{mn} h_{mn} e^{-i x_{mn} q_{op}}\]</div>
<p>corresponding <cite>np.fft.rfft</cite> and <cite>fftengine.fft</cite></p>
<p>fourier space input fields are assumed to be linked to the realspace field through
this fourier transform.</p>
<p>fourier inverse transform:</p>
<div class="math notranslate nohighlight">
\[h_{mn} = \frac{1}{n_x n_y}
\sum_{op} \tilde h_{op} e^{i x_{mn} q_{op}}\]</div>
<p>corresponding <cite>np.fft.irfft</cite> and <cite>fftengine.fft * fftengine.normalisation</cite></p>
<p>Note that this is different from the definition in
Jacobs, T. D. B. et al. Surf. Topogr.: Metrol. Prop. 5, 013001 (2017)
(Equations A.3, A.4), that is closer to the continuous fourier transform.</p>
</section>
<section id="parseval-s-theorem-convolutions-and-powers">
<h3>Parseval’s theorem, Convolutions and powers:<a class="headerlink" href="#parseval-s-theorem-convolutions-and-powers" title="Link to this heading"></a></h3>
<p>The prefactors in front of the sums depend on the definition of
the fourier transform.</p>
<p><a class="reference external" href="https://ccrma.stanford.edu/~jos/mdft/Convolution_Theorem.html">Convolution theorem</a>:</p>
<div class="math notranslate nohighlight">
\[(x * y)_m = \sum_n x_n y_{m-n} = IDFT(\tilde x_k \tilde y_k)_m\]</div>
<p>The <a class="reference external" href="https://ccrma.stanford.edu/~jos/mdft/Power_Theorem.html">power theorem</a>
can be deduced from the convolution theorem and states that:</p>
<div class="math notranslate nohighlight">
\[\sum_n x_n \overline{y_n} = \frac{1}{N} \sum_n \tilde x_n
                            \overline{\tilde y_n}\]</div>
<p>Parseval’s Theorem is a special case of the power theorem:</p>
<div class="math notranslate nohighlight">
\[\sum_n |x_n|^2 = \frac{1}{N} \sum_n |\tilde x_n|^2\]</div>
<p>When the fourier space array contains only half the spectrum, making use of
hermitian symmetry, extra care has to be taken when performing the sum.</p>
<p># TODO</p>
</section>
<section id="mufft-fourier-transform">
<h3>muFFT fourier transform:<a class="headerlink" href="#mufft-fourier-transform" title="Link to this heading"></a></h3>
<p><cite>fft</cite> and <cite>ifft</cite> never applies the normalisation factor, meaning that you will need
to multiply <cite>ifft(fft)</cite> by <cite>1 / np.prod(nb_grid_pts) = fftengine.normalisation</cite>)
in order to have a roundtrip.</p>
</section>
<section id="mufft-vs-np-fft">
<h3>muFFT vs. np.fft:<a class="headerlink" href="#mufft-vs-np-fft" title="Link to this heading"></a></h3>
</section>
<section id="normalisation">
<h3>Normalisation:<a class="headerlink" href="#normalisation" title="Link to this heading"></a></h3>
<p><cite>np.fft.rfft</cite> &lt;–&gt; <cite>fftengine.fft</cite></p>
<p><cite>np.fft.irfft</cite> &lt;–&gt; <cite>fftengine.ifft * fftengine.normalisation</cite></p>
</section>
<section id="d-fft">
<h3>2D FFT:<a class="headerlink" href="#d-fft" title="Link to this heading"></a></h3>
<p>numpy by default transforms the last index first.</p>
<p>muFFT the first
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">real_buffer.array()[..]</span> <span class="pre">=</span> <span class="pre">a</span>
<span class="pre">fftengine.fft(real_buffer,</span> <span class="pre">fourier_buffer)</span>
<span class="pre">fourier_buffer</span> <span class="pre">&lt;--&gt;</span> <span class="pre">np.rfft2(a.T).T</span> <span class="pre">&lt;--&gt;</span> <span class="pre">np.fft.rfft2(a,</span> <span class="pre">axes=(1,0))</span>
<span class="pre">`</span></code>
# FIXME: &#64;pastewka: I expected the fourier array to be transposed, so there is a
#                   wrapper swapping the indexes and the array
#                   is transposed in memory ?</p>
</section>
<dl class="py class">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.BndSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ContactMechanics.FFTElasticHalfSpace.</span></span><span class="sig-name descname"><span class="pre">BndSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">large</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">small</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.BndSet" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></p>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">count</span></code>(value, /)</p></td>
<td><p>Return number of occurrences of value.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code>(value[, start, stop])</p></td>
<td><p>Return first index of value.</p></td>
</tr>
</tbody>
</table>
<dl class="py attribute">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.BndSet.large">
<span class="sig-name descname"><span class="pre">large</span></span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.BndSet.large" title="Link to this definition"></a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.BndSet.small">
<span class="sig-name descname"><span class="pre">small</span></span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.BndSet.small" title="Link to this definition"></a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ContactMechanics.FFTElasticHalfSpace.</span></span><span class="sig-name descname"><span class="pre">FreeFFTElasticHalfSpace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace" title="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">PeriodicFFTElasticHalfSpace</span></code></a></p>
<p>Uses the FFT to solve the displacements and stresses in an non-periodic
elastic Halfspace due to a given array of point forces. Uses the Green’s
functions formulaiton of Johnson (1985, p. 54). The application of the FFT
to a nonperiodic domain is explained in Hockney (1969, p. 178.)</p>
<p>K. L. Johnson. (1985). Contact Mechanics. [Online]. Cambridge: Cambridge
University Press. Available from: Cambridge Books Online
&lt;<a class="reference external" href="http://dx.doi.org/10.1017/CBO9781139171731">http://dx.doi.org/10.1017/CBO9781139171731</a>&gt; [Accessed 16 February 2015]</p>
<p>R. W. HOCKNEY, “The potential calculation and some applications,” Methods
of Computational Physics, B. Adler, S. Fernback and M. Rotenberg (Eds.),
Academic Press, New York, 1969, pp. 136-211.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>area_per_pt</strong></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">communicator</span></code></dt><dd><p>Return the MPI communicator</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim</span></code></dt><dd><p>return the substrate’s physical dimension</p>
</dd>
<dt><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.domain_boundary_mask" title="ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.domain_boundary_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">domain_boundary_mask</span></code></a></dt><dd><p>Returns a mask of the points that are on the boundary of the domain</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">fourier_locations</span></code></dt><dd><p>When working in Parallel one processor holds only Part of the Data</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">fourier_slices</span></code></dt><dd><p>When working in Parallel one processor holds only Part of the Data</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">local_topography_subdomain_slices</span></code></dt><dd><p>slice representing the local subdomain without the padding area</p>
</dd>
<dt><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.nb_domain_grid_pts" title="ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.nb_domain_grid_pts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nb_domain_grid_pts</span></code></a></dt><dd><p>usually, the nb_grid_pts of the system is equal to the geometric</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">nb_fourier_grid_pts</span></code></dt><dd><p>When working in Parallel one processor holds only Part of the Data</p>
</dd>
<dt><strong>nb_grid_pts</strong></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">nb_subdomain_grid_pts</span></code></dt><dd><p>When working in Parallel one processor holds only Part of the Data</p>
</dd>
<dt><strong>physical_sizes</strong></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">subdomain_locations</span></code></dt><dd><p>When working in Parallel one processor holds only Part of the Data</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">subdomain_slices</span></code></dt><dd><p>When working in Parallel one processor holds only Part of the Data</p>
</dd>
<dt><strong>topography_nb_subdomain_grid_pts</strong></dt><dd></dd>
<dt><strong>topography_subdomain_locations</strong></dt><dd></dd>
<dt><strong>topography_subdomain_slices</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.FreeBoundaryError" title="ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.FreeBoundaryError"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FreeBoundaryError</span></code></a>(message)</p></td>
<td><p>called when the forces overlap into the padding region (i.e. the outer ring of the force array equals zero), needing an increase of the nb_grid_pts.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.check" title="ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.check"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check</span></code></a>([force])</p></td>
<td><p>Checks wether force is still in the value range handled correctly :param force:</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.check_boundaries" title="ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.check_boundaries"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_boundaries</span></code></a>([force, tol])</p></td>
<td><p>Raises an error if the forces are not zero at the boundary of the active domain</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute</span></code>(disp[, pot, forces])</p></td>
<td><p>computes and stores the elastic energy and/or surface forces the as function of the surface displacement.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_k</span></code>(disp_k[, pot, forces])</p></td>
<td><p>computes and stores the elastic energy and/or surface forces the as function of the surface displacement in Fourier Space.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate</span></code>(disp[, pot, forces])</p></td>
<td><p>Evaluates the elastic energy and the point forces Keyword Arguments: disp   -- array of distances pot    -- (default True) if true, returns potential energy forces -- (default False) if true, returns forces</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.evaluate_disp" title="ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.evaluate_disp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate_disp</span></code></a>(forces)</p></td>
<td><p>Computes the displacement due to a given force array Keyword Arguments: forces   -- a numpy array containing point forces (<em>not</em> pressures)</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate_elastic_energy</span></code>(forces, disp)</p></td>
<td><p>computes and returns the elastic energy due to forces and displacements Arguments: forces -- array of forces disp   -- array of displacements</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate_elastic_energy_k_space</span></code>(kforces, kdisp)</p></td>
<td><p>Computes the Energy due to forces and displacements using their Fourier representation.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate_force</span></code>(disp)</p></td>
<td><p>Computes the force (<em>not</em> pressures) due to a given displacement array.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate_k</span></code>(disp_k[, pot, forces])</p></td>
<td><p>Evaluates the elastic energy and the point forces in fourier sapce or k-space or reciprocal space.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate_k_disp</span></code>(forces)</p></td>
<td><p>Computes the K-space displacement due to a given force array</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate_k_force</span></code>(disp)</p></td>
<td><p>Computes the K-space forces (<em>not</em> pressures) due to a given displacement array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate_k_force_k</span></code>(disp_k)</p></td>
<td><p>Computes the K-space forces (<em>not</em> pressures) due to a given K-space displacement array.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate_scalar_product_k_space</span></code>(ka, kb)</p></td>
<td><p>Computes the scalar product, i.e. the power, between the <cite>a</cite> and <cite>b</cite>, given their fourier representation.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_periodic</span></code>()</p></td>
<td><p>non-periodic substrates can use some optimisations</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.spawn_child" title="ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.spawn_child"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spawn_child</span></code></a>(nb_grid_pts)</p></td>
<td><p>returns an instance with same physical properties with a smaller computational grid</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>Error</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py exception">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.FreeBoundaryError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">FreeBoundaryError</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">message</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.FreeBoundaryError" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<p>called when the forces overlap into the padding region
(i.e. the outer ring of the force array equals zero),
needing an increase of the nb_grid_pts</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.check">
<span class="sig-name descname"><span class="pre">check</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">force</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.check" title="Link to this definition"></a></dt>
<dd><p>Checks wether force is still in the value range handled correctly
:param force:</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.check_boundaries">
<span class="sig-name descname"><span class="pre">check_boundaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">force</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.check_boundaries" title="Link to this definition"></a></dt>
<dd><p>Raises an error if the forces are not zero at the boundary of the
active domain</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>force</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.domain_boundary_mask">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">domain_boundary_mask</span></span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.domain_boundary_mask" title="Link to this definition"></a></dt>
<dd><p>Returns a mask of the points that are on the boundary of the domain</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool ndarray with size self.topography_nb_subdomain_grid_pts</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.evaluate_disp">
<span class="sig-name descname"><span class="pre">evaluate_disp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">forces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.evaluate_disp" title="Link to this definition"></a></dt>
<dd><p>Computes the displacement due to a given force array
Keyword Arguments:
forces   – a numpy array containing point forces (<em>not</em> pressures)</p>
<p>if running in MPI this should be only the forces in the Subdomain</p>
<p>if running in serial one can give the force array with or without the
padded region</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'free_fft_elastic_halfspace'</span></em><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.nb_domain_grid_pts">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nb_domain_grid_pts</span></span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.nb_domain_grid_pts" title="Link to this definition"></a></dt>
<dd><p>usually, the nb_grid_pts of the system is equal to the geometric
nb_grid_pts (of the surface). For example free boundary conditions,
require the computational nb_grid_pts to differ from the geometric one,
see FreeFFTElasticHalfSpace.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.spawn_child">
<span class="sig-name descname"><span class="pre">spawn_child</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nb_grid_pts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.spawn_child" title="Link to this definition"></a></dt>
<dd><p>returns an instance with same physical properties with a smaller
computational grid</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.topography_nb_subdomain_grid_pts">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">topography_nb_subdomain_grid_pts</span></span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.FreeFFTElasticHalfSpace.topography_nb_subdomain_grid_pts" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ContactMechanics.FFTElasticHalfSpace.</span></span><span class="sig-name descname"><span class="pre">PeriodicFFTElasticHalfSpace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ContactMechanics.Substrates.ElasticSubstrate" title="ContactMechanics.Substrates.ElasticSubstrate"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElasticSubstrate</span></code></a></p>
<p>Uses the FFT to solve the displacements and stresses in an elastic
Halfspace due to a given array of point forces. This halfspace
implementation cheats somewhat: since a net pressure would result in
infinite displacement, the first term of the FFT is systematically
dropped.
The implementation follows the description in Stanley &amp; Kato J. Tribol.
119(3), 481-485 (Jul 01, 1997)</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>area_per_pt</strong></dt><dd></dd>
<dt><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.communicator" title="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.communicator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">communicator</span></code></a></dt><dd><p>Return the MPI communicator</p>
</dd>
<dt><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.dim" title="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.dim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim</span></code></a></dt><dd><p>return the substrate’s physical dimension</p>
</dd>
<dt><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.fourier_locations" title="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.fourier_locations"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fourier_locations</span></code></a></dt><dd><p>When working in Parallel one processor holds only Part of the Data</p>
</dd>
<dt><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.fourier_slices" title="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.fourier_slices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fourier_slices</span></code></a></dt><dd><p>When working in Parallel one processor holds only Part of the Data</p>
</dd>
<dt><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.local_topography_subdomain_slices" title="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.local_topography_subdomain_slices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">local_topography_subdomain_slices</span></code></a></dt><dd><p>slice representing the local subdomain without the padding area</p>
</dd>
<dt><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.nb_domain_grid_pts" title="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.nb_domain_grid_pts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nb_domain_grid_pts</span></code></a></dt><dd><p>usually, the nb_grid_pts of the system is equal to the geometric</p>
</dd>
<dt><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.nb_fourier_grid_pts" title="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.nb_fourier_grid_pts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nb_fourier_grid_pts</span></code></a></dt><dd><p>When working in Parallel one processor holds only Part of the Data</p>
</dd>
<dt><strong>nb_grid_pts</strong></dt><dd></dd>
<dt><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.nb_subdomain_grid_pts" title="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.nb_subdomain_grid_pts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nb_subdomain_grid_pts</span></code></a></dt><dd><p>When working in Parallel one processor holds only Part of the Data</p>
</dd>
<dt><strong>physical_sizes</strong></dt><dd></dd>
<dt><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.subdomain_locations" title="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.subdomain_locations"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subdomain_locations</span></code></a></dt><dd><p>When working in Parallel one processor holds only Part of the Data</p>
</dd>
<dt><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.subdomain_slices" title="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.subdomain_slices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subdomain_slices</span></code></a></dt><dd><p>When working in Parallel one processor holds only Part of the Data</p>
</dd>
<dt><strong>topography_nb_subdomain_grid_pts</strong></dt><dd></dd>
<dt><strong>topography_subdomain_locations</strong></dt><dd></dd>
<dt><strong>topography_subdomain_slices</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">check</span></code>([force])</p></td>
<td><p>Checks wether force is still in the value range handled correctly.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute</span></code>(disp[, pot, forces])</p></td>
<td><p>computes and stores the elastic energy and/or surface forces the as function of the surface displacement.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_k</span></code>(disp_k[, pot, forces])</p></td>
<td><p>computes and stores the elastic energy and/or surface forces the as function of the surface displacement in Fourier Space.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate" title="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate</span></code></a>(disp[, pot, forces])</p></td>
<td><p>Evaluates the elastic energy and the point forces Keyword Arguments: disp   -- array of distances pot    -- (default True) if true, returns potential energy forces -- (default False) if true, returns forces</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_disp" title="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_disp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate_disp</span></code></a>(forces)</p></td>
<td><p>Computes the displacement due to a given force array Keyword Arguments: forces   -- a numpy array containing point forces (<em>not</em> pressures)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_elastic_energy" title="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_elastic_energy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate_elastic_energy</span></code></a>(forces, disp)</p></td>
<td><p>computes and returns the elastic energy due to forces and displacements Arguments: forces -- array of forces disp   -- array of displacements</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_elastic_energy_k_space" title="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_elastic_energy_k_space"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate_elastic_energy_k_space</span></code></a>(kforces, kdisp)</p></td>
<td><p>Computes the Energy due to forces and displacements using their Fourier representation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_force" title="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_force"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate_force</span></code></a>(disp)</p></td>
<td><p>Computes the force (<em>not</em> pressures) due to a given displacement array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_k" title="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_k"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate_k</span></code></a>(disp_k[, pot, forces])</p></td>
<td><p>Evaluates the elastic energy and the point forces in fourier sapce or k-space or reciprocal space.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_k_disp" title="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_k_disp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate_k_disp</span></code></a>(forces)</p></td>
<td><p>Computes the K-space displacement due to a given force array</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_k_force" title="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_k_force"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate_k_force</span></code></a>(disp)</p></td>
<td><p>Computes the K-space forces (<em>not</em> pressures) due to a given displacement array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_k_force_k" title="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_k_force_k"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate_k_force_k</span></code></a>(disp_k)</p></td>
<td><p>Computes the K-space forces (<em>not</em> pressures) due to a given K-space displacement array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_scalar_product_k_space" title="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_scalar_product_k_space"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate_scalar_product_k_space</span></code></a>(ka, kb)</p></td>
<td><p>Computes the scalar product, i.e. the power, between the <cite>a</cite> and <cite>b</cite>, given their fourier representation.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_periodic</span></code>()</p></td>
<td><p>non-periodic substrates can use some optimisations</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">spawn_child</span></code>(dummy)</p></td>
<td><p>does nothing for most substrates.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>Error</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py property">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.area_per_pt">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">area_per_pt</span></span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.area_per_pt" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.communicator">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">communicator</span></span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.communicator" title="Link to this definition"></a></dt>
<dd><p>Return the MPI communicator</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.dim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dim</span></span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.dim" title="Link to this definition"></a></dt>
<dd><p>return the substrate’s physical dimension</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">disp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate" title="Link to this definition"></a></dt>
<dd><p>Evaluates the elastic energy and the point forces
Keyword Arguments:
disp   – array of distances
pot    – (default True) if true, returns potential energy
forces – (default False) if true, returns forces</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_disp">
<span class="sig-name descname"><span class="pre">evaluate_disp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">forces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_disp" title="Link to this definition"></a></dt>
<dd><p>Computes the displacement due to a given force array
Keyword Arguments:
forces   – a numpy array containing point forces (<em>not</em> pressures)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_elastic_energy">
<span class="sig-name descname"><span class="pre">evaluate_elastic_energy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">forces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_elastic_energy" title="Link to this definition"></a></dt>
<dd><p>computes and returns the elastic energy due to forces and displacements
Arguments:
forces – array of forces
disp   – array of displacements</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_elastic_energy_k_space">
<span class="sig-name descname"><span class="pre">evaluate_elastic_energy_k_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kforces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kdisp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_elastic_energy_k_space" title="Link to this definition"></a></dt>
<dd><p>Computes the Energy due to forces and displacements using their Fourier
representation.</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}E_{el} &amp;= - \frac{1}{2} \sum_{ij} u_{ij} f_{ij}\\       &amp;= - \frac{1}{2} \frac{1}{n_x n_y} \sum_{kl} \tilde u_{kl} \overline{\tilde f_{kl}}\end{aligned}\end{align} \]</div>
<p>(<span class="math notranslate nohighlight">\(\tilde f_{ij} = - \tilde K_{ijkl} \tilde u_{kl}\)</span>)</p>
<p>In a parallelized code kforces and kdisp contain only the slice
attributed to this processor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kforces</strong> – array of complex type and of size substrate.nb_fourier_grid_pts
Fourier representation (output of a 2D rfftn) of the forces acting on the grid points</p></li>
<li><p><strong>kdisp</strong> – array of complex type and of physical_sizes substrate.nb_fourier_grid_pts
Fourier representation (output of a 2D rfftn) of the displacements of the grid points</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The elastic energy due to the forces and displacements</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>E</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_force">
<span class="sig-name descname"><span class="pre">evaluate_force</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">disp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_force" title="Link to this definition"></a></dt>
<dd><p>Computes the force (<em>not</em> pressures) due to a given displacement
array.</p>
<p>Keyword Arguments:
disp   – a numpy array containing point displacements</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_k">
<span class="sig-name descname"><span class="pre">evaluate_k</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">disp_k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_k" title="Link to this definition"></a></dt>
<dd><p>Evaluates the elastic energy and the point forces in fourier sapce
or k-space or reciprocal space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_k_disp">
<span class="sig-name descname"><span class="pre">evaluate_k_disp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">forces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_k_disp" title="Link to this definition"></a></dt>
<dd><p>Computes the K-space displacement due to a given force array</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>forces</strong> (<em>ndarray</em>) – a numpy array containing point forces (<em>not</em> pressures)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>displacement</strong> – displacement in k-space</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_k_force">
<span class="sig-name descname"><span class="pre">evaluate_k_force</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">disp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_k_force" title="Link to this definition"></a></dt>
<dd><p>Computes the K-space forces (<em>not</em> pressures) due to a given
displacement array.</p>
<p>Keyword Arguments:
disp   – a numpy array containing point displacements</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_k_force_k">
<span class="sig-name descname"><span class="pre">evaluate_k_force_k</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">disp_k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_k_force_k" title="Link to this definition"></a></dt>
<dd><p>Computes the K-space forces (<em>not</em> pressures) due to a given
K-space displacement array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>disp</strong> (<em>ndarray k-space</em>) – a numpy k-space array containing point displacements</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>force_k</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>nd array k-sapce forces</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_scalar_product_k_space">
<span class="sig-name descname"><span class="pre">evaluate_scalar_product_k_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ka</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.evaluate_scalar_product_k_space" title="Link to this definition"></a></dt>
<dd><p>Computes the scalar product, i.e. the power, between the <cite>a</cite> and <cite>b</cite>,
given their fourier representation.</p>
<p><a class="reference external" href="https://ccrma.stanford.edu/~jos/mdft/Power_Theorem.html">Power theorem</a>:</p>
<div class="math notranslate nohighlight">
\[P = \sum_{ij} a_{ij} b_{ij} =
    \frac{1}{n_x n_y}\sum_{ij}
    \tilde a_{ij} \overline{\tilde b_{ij}}\]</div>
<p>Note that for <cite>a</cite>, <cite>b</cite> real,</p>
<div class="math notranslate nohighlight">
\[P = \sum_{kl} Re(\tilde a_{kl}) Re(\tilde b_{kl})\]</div>
<ul class="simple">
<li><p>Im(tilde a_{kl}) Im(tilde b_{kl})</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ka</strong> – arrays of complex type and of size substrate.nb_fourier_grid_pts
Fourier representation (output of a 2D rfftn) <cite>a</cite> (resp. <cite>b</cite>)
(<cite>nx, ny</cite> real array)</p></li>
<li><p><strong>kb</strong> – arrays of complex type and of size substrate.nb_fourier_grid_pts
Fourier representation (output of a 2D rfftn) <cite>a</cite> (resp. <cite>b</cite>)
(<cite>nx, ny</cite> real array)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The scalar product of a and b</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>P</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.fourier_locations">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fourier_locations</span></span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.fourier_locations" title="Link to this definition"></a></dt>
<dd><p>When working in Parallel one processor holds only Part of the Data</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.fourier_slices">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fourier_slices</span></span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.fourier_slices" title="Link to this definition"></a></dt>
<dd><p>When working in Parallel one processor holds only Part of the Data</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.local_topography_subdomain_slices">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">local_topography_subdomain_slices</span></span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.local_topography_subdomain_slices" title="Link to this definition"></a></dt>
<dd><p>slice representing the local subdomain without the padding area</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'periodic_fft_elastic_halfspace'</span></em><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.nb_domain_grid_pts">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nb_domain_grid_pts</span></span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.nb_domain_grid_pts" title="Link to this definition"></a></dt>
<dd><p>usually, the nb_grid_pts of the system is equal to the geometric
nb_grid_pts (of the surface). For example free boundary conditions,
require the computational nb_grid_pts to differ from the geometric one,
see FreeFFTElasticHalfSpace.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.nb_fourier_grid_pts">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nb_fourier_grid_pts</span></span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.nb_fourier_grid_pts" title="Link to this definition"></a></dt>
<dd><p>When working in Parallel one processor holds only Part of the Data</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.nb_grid_pts">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nb_grid_pts</span></span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.nb_grid_pts" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.nb_subdomain_grid_pts">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nb_subdomain_grid_pts</span></span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.nb_subdomain_grid_pts" title="Link to this definition"></a></dt>
<dd><p>When working in Parallel one processor holds only Part of the Data</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.physical_sizes">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">physical_sizes</span></span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.physical_sizes" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.subdomain_locations">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">subdomain_locations</span></span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.subdomain_locations" title="Link to this definition"></a></dt>
<dd><p>When working in Parallel one processor holds only Part of the Data</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.subdomain_slices">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">subdomain_slices</span></span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.subdomain_slices" title="Link to this definition"></a></dt>
<dd><p>When working in Parallel one processor holds only Part of the Data</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.topography_nb_subdomain_grid_pts">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">topography_nb_subdomain_grid_pts</span></span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.topography_nb_subdomain_grid_pts" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.topography_subdomain_locations">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">topography_subdomain_locations</span></span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.topography_subdomain_locations" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.topography_subdomain_slices">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">topography_subdomain_slices</span></span><a class="headerlink" href="#ContactMechanics.FFTElasticHalfSpace.PeriodicFFTElasticHalfSpace.topography_subdomain_slices" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-ContactMechanics.Factory">
<span id="contactmechanics-factory-module"></span><h2>ContactMechanics.Factory module<a class="headerlink" href="#module-ContactMechanics.Factory" title="Link to this heading"></a></h2>
<p>Implements a convenient Factory function for Contact System creation</p>
<dl class="py function">
<dt class="sig sig-object py" id="ContactMechanics.Factory.make_contact_system">
<span class="sig-prename descclassname"><span class="pre">ContactMechanics.Factory.</span></span><span class="sig-name descname"><span class="pre">make_contact_system</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">topography</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Factory.make_contact_system" title="Link to this definition"></a></dt>
<dd><p>Factory function for contact systems. Checks the compatibility between the
substrate, interaction method and surface and returns an object of the
appropriate type to handle it. The returned object is always of a subtype
of SystemBase.</p>
<p>This function can be called in different ways:
- provide the elastic propoerties of the substrates</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">topography</span><span class="o">.</span><span class="n">make_contact_system</span><span class="p">(</span><span class="n">young</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">for other possibilities, i.e. finite thickness\</span>
<span class="go">check the arguments of `FFTElasticHalfspace` or `FreeFFTElasticHalfspace`</span>
</pre></div>
</div>
<ul class="simple">
<li><p>provide an already instantiated substrate
&gt;&gt;&gt; topography.make_contact_system(substrate=substrate)</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ContactMechanics.Factory.make_plastic_contact_system">
<span class="sig-prename descclassname"><span class="pre">ContactMechanics.Factory.</span></span><span class="sig-name descname"><span class="pre">make_plastic_contact_system</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">topography</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Factory.make_plastic_contact_system" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ContactMechanics.Factory.make_plastic_system">
<span class="sig-prename descclassname"><span class="pre">ContactMechanics.Factory.</span></span><span class="sig-name descname"><span class="pre">make_plastic_system</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Factory.make_plastic_system" title="Link to this definition"></a></dt>
<dd><p>Factory function for contact systems. Checks the compatibility between the
substrate, interaction method and surface and returns an object of the
appropriate type to handle it. The returned object is always of a subtype
of SystemBase.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ContactMechanics.Factory.make_system">
<span class="sig-prename descclassname"><span class="pre">ContactMechanics.Factory.</span></span><span class="sig-name descname"><span class="pre">make_system</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Factory.make_system" title="Link to this definition"></a></dt>
<dd><p>Factory function for contact systems. Checks the compatibility between the
substrate, interaction method and surface and returns an object of the
appropriate type to handle it. The returned object is always of a subtype
of SystemBase.</p>
</dd></dl>

</section>
<section id="module-ContactMechanics.PipelineFunction">
<span id="contactmechanics-pipelinefunction-module"></span><h2>ContactMechanics.PipelineFunction module<a class="headerlink" href="#module-ContactMechanics.PipelineFunction" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="ContactMechanics.PipelineFunction.contact_mechanics">
<span class="sig-prename descclassname"><span class="pre">ContactMechanics.PipelineFunction.</span></span><span class="sig-name descname"><span class="pre">contact_mechanics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">substrate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsteps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offsets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pressures</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hardness</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results_callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimizer_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.PipelineFunction.contact_mechanics" title="Link to this definition"></a></dt>
<dd><p>Carry out an automated contact mechanics calculations. The pipeline
function return thermodynamic data (averages over the contact area,
e.g. the total force or the total area). Spatially resolved data
(pressure maps, displacement maps, etc.) are passed to the callback
function. If this data is reqired, the callback function needs to take
care of analyzing or storing it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>self</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">SurfaceTopography.UniformTopographyInterface</span></code>) – Topography on which to carry out the contact calculation.</p></li>
<li><p><strong>substrate</strong> (<em>str</em><em>, </em><em>optional</em>) – Specifies whether substrate should be ‘periodic’ or ‘nonperiodic’. If
set to None, it will be chosen according to whether the topography is
periodic or nonperiodic.
(Default: None)</p></li>
<li><p><strong>nsteps</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of contact steps. (Default: 10)</p></li>
<li><p><strong>offsets</strong> (<em>list</em><em> of </em><em>floats</em><em>, </em><em>optional</em>) – List with offsets. Can only be set if <cite>nsteps</cite> and <cite>pressures</cite> is
set to None. (Default: None)</p></li>
<li><p><strong>pressures</strong> (<em>list</em><em> of </em><em>floats</em><em>, </em><em>optional</em>) – List with pressures in units of E*. Can only be set if <cite>nsteps</cite> and
<cite>offsets</cite> is set to None. (Default: None)</p></li>
<li><p><strong>hardness</strong> (<em>float</em><em>, </em><em>optional</em>) – Hardness in units of E*. Calculation is fully elastic if set to None.
(Default: None)</p></li>
<li><p><strong>maxiter</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of interations. (Default: 100)</p></li>
<li><p><strong>results_callback</strong> (<em>func</em><em>, </em><em>optional</em>) – Callback function receiving displacement, pressure, etc. fields.
(Default: None)</p></li>
<li><p><strong>optimizer_kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Optional arguments passed on to the optimizer. (Default: {})</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>mean_pressure</strong> (<em>np.ndarray</em>) – Array with mean pressure for each calculation step.</p></li>
<li><p><strong>total_contact_area</strong> (<em>np.ndarray</em>) – Array with total area for each calculation step.</p></li>
<li><p><strong>mean_displacement</strong> (<em>np.ndarray</em>) – Array with mean displacement for each calculation step.</p></li>
<li><p><strong>mean_gap</strong> (<em>np.ndarray</em>) – Array with mean gap for each calculation step.</p></li>
<li><p><strong>converged</strong> (<em>np.ndarray</em>) – Convergence information for each calculation step. Unconverged
results are still returned but should be interpreted with care.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-ContactMechanics.PlasticSystemSpecialisations">
<span id="contactmechanics-plasticsystemspecialisations-module"></span><h2>ContactMechanics.PlasticSystemSpecialisations module<a class="headerlink" href="#module-ContactMechanics.PlasticSystemSpecialisations" title="Link to this heading"></a></h2>
<p>implements plastic mapping algorithms for contact systems</p>
<dl class="py class">
<dt class="sig sig-object py" id="ContactMechanics.PlasticSystemSpecialisations.PlasticNonSmoothContactSystem">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ContactMechanics.PlasticSystemSpecialisations.</span></span><span class="sig-name descname"><span class="pre">PlasticNonSmoothContactSystem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">substrate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.PlasticSystemSpecialisations.PlasticNonSmoothContactSystem" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem" title="ContactMechanics.Systems.NonSmoothContactSystem"><code class="xref py py-class docutils literal notranslate"><span class="pre">NonSmoothContactSystem</span></code></a></p>
<p>This system implements a simple penetration hardness model.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">nb_grid_pts</span></code></dt><dd><p>For systems, nb_grid_pts can become non-trivial</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">callback</span></code>([force])</p></td>
<td><p>Simple callback function that can be handed over to scipy's minimize to get updates during minimisation Parameters: force -- (default False) whether to include the norm of the force          vector in the update message</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_contact_area</span></code>()</p></td>
<td><p>computes and returns the total contact area</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_contact_coordinates</span></code>()</p></td>
<td><p>returns an array of all coordinates, where contact pressure is repulsive.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_gap</span></code>(disp, offset, *profile_args, ...)</p></td>
<td><p>evaluate the gap between surface and substrate.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_nb_contact_pts</span></code>()</p></td>
<td><p>compute and return the number of contact points.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_normal_force</span></code>()</p></td>
<td><p>computes and returns the sum of all forces</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_relative_contact_area</span></code>()</p></td>
<td><p>compute and return the relative contact area:</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dual_hessian_product</span></code>(pressure)</p></td>
<td><p>Returns the hessian product of the dual_objective function.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dual_minimize_proxy</span></code>(offset[, init_force, ...])</p></td>
<td><p>Convenience function for DUAL minimisation (pixel forces as variables).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dual_objective</span></code>(offset[, gradient])</p></td>
<td><p>Objective function to handle dual objective, i.e. the Legendre transformation from displacements as variable to pressures (the Lagrange multiplier) as variable.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate</span></code>(disp, offset[, pot, forces, logger])</p></td>
<td><p>Compute the energies and forces in the system for a given displacement field.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate_dual</span></code>(press, offset[, forces])</p></td>
<td><p>Computes the energies and forces in the system for a given pressure field.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.PlasticSystemSpecialisations.PlasticNonSmoothContactSystem.handles" title="ContactMechanics.PlasticSystemSpecialisations.PlasticNonSmoothContactSystem.handles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">handles</span></code></a>(substrate_type, surface_type, ...)</p></td>
<td><p>determines whether this class can handle the proposed system composition Keyword Arguments: substrate_type   -- instance of ElasticSubstrate subclass surface_type     --</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">hessian_product</span></code>(disp)</p></td>
<td><p>Computes the Hessian product for the objective function.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_proxy</span></code>()</p></td>
<td><p>subclasses may not be able to implement the full interface because they try to do something smart and internally compute a different system. They should declare to  to be proxies and provide a method called cls. deproxyfied() that returns the energy, force and displacement of the full problem based on its internal state. E.g at the end of an optimization, you could have: if system.is_proxy():     energy, force, disp = system.deproxyfied().</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">logger_input</span></code>()</p></td>
<td><p>Describes the current state of the system (during minimization)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">objective</span></code>(offset[, disp0, gradient, logger])</p></td>
<td><p>This helper method exposes a scipy.optimize-friendly interface to the evaluate() method.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">primal_hessian_product</span></code>(gap)</p></td>
<td><p>Returns the hessian product of the primal_objective function.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">primal_minimize_proxy</span></code>(offset[, init_gap, ...])</p></td>
<td><p>This function is a convenience function that simplifies the process of solving the primal minimisation problem where the gap is the variable.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">primal_objective</span></code>(offset[, gradient])</p></td>
<td><p>Solves the primal objective using gap as the variable.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape_minimisation_input</span></code>(in_array)</p></td>
<td><p>For minimisation of smart systems, the initial guess array (e.g. displacement) may have a non-intuitive shape and physical_sizes (The problem physical_sizes may be decreased, as for free, non-periodic systems, or increased as with augmented-lagrangian-type issues).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape_minimisation_output</span></code>(in_array)</p></td>
<td><p>For minimisation of smart systems, the output array (e.g. displacement) may have a non-intuitive shape and physical_sizes (The problem physical_sizes may be decreased, as for free, non-periodic systems, or increased as with augmented-lagrangian-type issues).</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>minimize_proxy</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.PlasticSystemSpecialisations.PlasticNonSmoothContactSystem.handles">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">handles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">substrate_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_domain_decomposed</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.PlasticSystemSpecialisations.PlasticNonSmoothContactSystem.handles" title="Link to this definition"></a></dt>
<dd><p>determines whether this class can handle the proposed system
composition
Keyword Arguments:
substrate_type   – instance of ElasticSubstrate subclass
surface_type     –</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.PlasticSystemSpecialisations.PlasticNonSmoothContactSystem.minimize_proxy">
<span class="sig-name descname"><span class="pre">minimize_proxy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.PlasticSystemSpecialisations.PlasticNonSmoothContactSystem.minimize_proxy" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-ContactMechanics.Substrates">
<span id="contactmechanics-substrates-module"></span><h2>ContactMechanics.Substrates module<a class="headerlink" href="#module-ContactMechanics.Substrates" title="Link to this heading"></a></h2>
<p>Base class for continuum mechanics models of halfspaces</p>
<dl class="py class">
<dt class="sig sig-object py" id="ContactMechanics.Substrates.ElasticSubstrate">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ContactMechanics.Substrates.</span></span><span class="sig-name descname"><span class="pre">ElasticSubstrate</span></span><a class="headerlink" href="#ContactMechanics.Substrates.ElasticSubstrate" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ContactMechanics.Substrates.Substrate" title="ContactMechanics.Substrates.Substrate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Substrate</span></code></a></p>
<p>Generic baseclass for elastic substrates</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">communicator</span></code></dt><dd><p>Return the MPI communicator</p>
</dd>
<dt><strong>nb_domain_grid_pts</strong></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">nb_subdomain_grid_pts</span></code></dt><dd><p>When working in Parallel one processor holds only Part of the Data</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">subdomain_locations</span></code></dt><dd><p>When working in Parallel one processor holds only Part of the Data</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">check</span></code>([force])</p></td>
<td><p>Checks wether force is still in the value range handled correctly.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ContactMechanics.Substrates.ElasticSubstrate.compute" title="ContactMechanics.Substrates.ElasticSubstrate.compute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute</span></code></a>(disp[, pot, forces])</p></td>
<td><p>computes and stores the elastic energy and/or surface forces the as function of the surface displacement.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.Substrates.ElasticSubstrate.compute_k" title="ContactMechanics.Substrates.ElasticSubstrate.compute_k"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_k</span></code></a>(disp_k[, pot, forces])</p></td>
<td><p>computes and stores the elastic energy and/or surface forces the as function of the surface displacement in Fourier Space.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ContactMechanics.Substrates.ElasticSubstrate.evaluate" title="ContactMechanics.Substrates.ElasticSubstrate.evaluate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate</span></code></a>(disp[, pot, forces])</p></td>
<td><p>computes and returns the elastic energy and/or surface forces as function of the surface displacement.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_periodic</span></code>()</p></td>
<td><p>non-periodic substrates can use some optimisations</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">spawn_child</span></code>(dummy)</p></td>
<td><p>does nothing for most substrates.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>Error</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Substrates.ElasticSubstrate.compute">
<span class="sig-name descname"><span class="pre">compute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">disp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Substrates.ElasticSubstrate.compute" title="Link to this definition"></a></dt>
<dd><p>computes and stores the elastic energy and/or surface forces
the as function of the surface displacement. Note that forces, not
surface pressures are expected. This is contrary to most formulations
in the literature, but convenient in the code (consistency with the
softWall interaction potentials). This choice may come back to bite me.
Parameters:
gap    – array containing the point-wise gap values
pot    – (default True) whether the energy should be evaluated
forces – (default False) whether the forces should be evaluated</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Substrates.ElasticSubstrate.compute_k">
<span class="sig-name descname"><span class="pre">compute_k</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">disp_k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Substrates.ElasticSubstrate.compute_k" title="Link to this definition"></a></dt>
<dd><p>computes and stores the elastic energy and/or surface forces
the as function of the surface displacement in Fourier Space.
Note that forces, not surface pressures are expected.
This is contrary to most formulations
in the literature, but convenient in the code (consistency with the
softWall interaction potentials). This choice may come back to bite me.
Parameters:
gap    – array containing the point-wise gap values
pot    – (default True) whether the energy should be evaluated
forces – (default False) whether the forces should be evaluated</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Substrates.ElasticSubstrate.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">disp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Substrates.ElasticSubstrate.evaluate" title="Link to this definition"></a></dt>
<dd><p>computes and returns the elastic energy and/or surface forces
as function of the surface displacement. See docstring for ‘compute’
for more details
Parameters:
gap    – array containing the point-wise gap values
pot    – (default True) whether the energy should be evaluated
forces – (default False) whether the forces should be evaluated</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ContactMechanics.Substrates.ElasticSubstrate.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'generic_elastic_halfspace'</span></em><a class="headerlink" href="#ContactMechanics.Substrates.ElasticSubstrate.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ContactMechanics.Substrates.PlasticSubstrate">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ContactMechanics.Substrates.</span></span><span class="sig-name descname"><span class="pre">PlasticSubstrate</span></span><a class="headerlink" href="#ContactMechanics.Substrates.PlasticSubstrate" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ContactMechanics.Substrates.Substrate" title="ContactMechanics.Substrates.Substrate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Substrate</span></code></a></p>
<p>Generic baseclass for plastic substrates</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">communicator</span></code></dt><dd><p>Return the MPI communicator</p>
</dd>
<dt><strong>nb_domain_grid_pts</strong></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">nb_subdomain_grid_pts</span></code></dt><dd><p>When working in Parallel one processor holds only Part of the Data</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">subdomain_locations</span></code></dt><dd><p>When working in Parallel one processor holds only Part of the Data</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">check</span></code>([force])</p></td>
<td><p>Checks wether force is still in the value range handled correctly.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_periodic</span></code>()</p></td>
<td><p>non-periodic substrates can use some optimisations</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">spawn_child</span></code>(dummy)</p></td>
<td><p>does nothing for most substrates.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>Error</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py attribute">
<dt class="sig sig-object py" id="ContactMechanics.Substrates.PlasticSubstrate.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'generic_plastic_halfspace'</span></em><a class="headerlink" href="#ContactMechanics.Substrates.PlasticSubstrate.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ContactMechanics.Substrates.Substrate">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ContactMechanics.Substrates.</span></span><span class="sig-name descname"><span class="pre">Substrate</span></span><a class="headerlink" href="#ContactMechanics.Substrates.Substrate" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Generic baseclass from which all substate classes derive</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#ContactMechanics.Substrates.Substrate.communicator" title="ContactMechanics.Substrates.Substrate.communicator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">communicator</span></code></a></dt><dd><p>Return the MPI communicator</p>
</dd>
<dt><strong>nb_domain_grid_pts</strong></dt><dd></dd>
<dt><a class="reference internal" href="#ContactMechanics.Substrates.Substrate.nb_subdomain_grid_pts" title="ContactMechanics.Substrates.Substrate.nb_subdomain_grid_pts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nb_subdomain_grid_pts</span></code></a></dt><dd><p>When working in Parallel one processor holds only Part of the Data</p>
</dd>
<dt><a class="reference internal" href="#ContactMechanics.Substrates.Substrate.subdomain_locations" title="ContactMechanics.Substrates.Substrate.subdomain_locations"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subdomain_locations</span></code></a></dt><dd><p>When working in Parallel one processor holds only Part of the Data</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.Substrates.Substrate.check" title="ContactMechanics.Substrates.Substrate.check"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check</span></code></a>([force])</p></td>
<td><p>Checks wether force is still in the value range handled correctly.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ContactMechanics.Substrates.Substrate.is_periodic" title="ContactMechanics.Substrates.Substrate.is_periodic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_periodic</span></code></a>()</p></td>
<td><p>non-periodic substrates can use some optimisations</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.Substrates.Substrate.spawn_child" title="ContactMechanics.Substrates.Substrate.spawn_child"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spawn_child</span></code></a>(dummy)</p></td>
<td><p>does nothing for most substrates.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>Error</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py exception">
<dt class="sig sig-object py" id="ContactMechanics.Substrates.Substrate.Error">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Error</span></span><a class="headerlink" href="#ContactMechanics.Substrates.Substrate.Error" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Substrates.Substrate.check">
<span class="sig-name descname"><span class="pre">check</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">force</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Substrates.Substrate.check" title="Link to this definition"></a></dt>
<dd><p>Checks wether force is still in the value range handled correctly.
In this case all forces are ok.
:param force:</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ContactMechanics.Substrates.Substrate.communicator">
<em class="property"><span class="pre">abstract</span><span class="w"> </span><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">communicator</span></span><a class="headerlink" href="#ContactMechanics.Substrates.Substrate.communicator" title="Link to this definition"></a></dt>
<dd><p>Return the MPI communicator</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Substrates.Substrate.is_periodic">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_periodic</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Substrates.Substrate.is_periodic" title="Link to this definition"></a></dt>
<dd><p>non-periodic substrates can use some optimisations</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ContactMechanics.Substrates.Substrate.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'generic_halfspace'</span></em><a class="headerlink" href="#ContactMechanics.Substrates.Substrate.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ContactMechanics.Substrates.Substrate.nb_domain_grid_pts">
<em class="property"><span class="pre">abstract</span><span class="w"> </span><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nb_domain_grid_pts</span></span><a class="headerlink" href="#ContactMechanics.Substrates.Substrate.nb_domain_grid_pts" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ContactMechanics.Substrates.Substrate.nb_subdomain_grid_pts">
<em class="property"><span class="pre">abstract</span><span class="w"> </span><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nb_subdomain_grid_pts</span></span><a class="headerlink" href="#ContactMechanics.Substrates.Substrate.nb_subdomain_grid_pts" title="Link to this definition"></a></dt>
<dd><p>When working in Parallel one processor holds only Part of the Data</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Substrates.Substrate.spawn_child">
<span class="sig-name descname"><span class="pre">spawn_child</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dummy</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Substrates.Substrate.spawn_child" title="Link to this definition"></a></dt>
<dd><p>does nothing for most substrates.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ContactMechanics.Substrates.Substrate.subdomain_locations">
<em class="property"><span class="pre">abstract</span><span class="w"> </span><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">subdomain_locations</span></span><a class="headerlink" href="#ContactMechanics.Substrates.Substrate.subdomain_locations" title="Link to this definition"></a></dt>
<dd><p>When working in Parallel one processor holds only Part of the Data</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-ContactMechanics.Systems">
<span id="contactmechanics-systems-module"></span><h2>ContactMechanics.Systems module<a class="headerlink" href="#module-ContactMechanics.Systems" title="Link to this heading"></a></h2>
<p>Defines the interface for contact mechanics systems</p>
<dl class="py exception">
<dt class="sig sig-object py" id="ContactMechanics.Systems.IncompatibleFormulationError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ContactMechanics.Systems.</span></span><span class="sig-name descname"><span class="pre">IncompatibleFormulationError</span></span><a class="headerlink" href="#ContactMechanics.Systems.IncompatibleFormulationError" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="ContactMechanics.Systems.IncompatibleResolutionError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ContactMechanics.Systems.</span></span><span class="sig-name descname"><span class="pre">IncompatibleResolutionError</span></span><a class="headerlink" href="#ContactMechanics.Systems.IncompatibleResolutionError" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ContactMechanics.Systems.NonSmoothContactSystem">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ContactMechanics.Systems.</span></span><span class="sig-name descname"><span class="pre">NonSmoothContactSystem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">substrate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.NonSmoothContactSystem" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ContactMechanics.Systems.SystemBase" title="ContactMechanics.Systems.SystemBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">SystemBase</span></code></a></p>
<p>For non-smooth contact mechanics (i.e, the equlibrium is the solution to a
constrained optimisation problem with a non-zero gradient of the energy
functional at the solution). The classic contact problems, for which the
interaction between the tribopartners is just non-penetration without
adhesion, belong to this type of system</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.nb_grid_pts" title="ContactMechanics.Systems.NonSmoothContactSystem.nb_grid_pts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nb_grid_pts</span></code></a></dt><dd><p>For systems, nb_grid_pts can become non-trivial</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">callback</span></code>([force])</p></td>
<td><p>Simple callback function that can be handed over to scipy's minimize to get updates during minimisation Parameters: force -- (default False) whether to include the norm of the force          vector in the update message</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_contact_area</span></code>()</p></td>
<td><p>computes and returns the total contact area</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.compute_contact_coordinates" title="ContactMechanics.Systems.NonSmoothContactSystem.compute_contact_coordinates"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_contact_coordinates</span></code></a>()</p></td>
<td><p>returns an array of all coordinates, where contact pressure is repulsive.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_gap</span></code>(disp, offset, *profile_args, ...)</p></td>
<td><p>evaluate the gap between surface and substrate.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.compute_nb_contact_pts" title="ContactMechanics.Systems.NonSmoothContactSystem.compute_nb_contact_pts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_nb_contact_pts</span></code></a>()</p></td>
<td><p>compute and return the number of contact points.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.compute_normal_force" title="ContactMechanics.Systems.NonSmoothContactSystem.compute_normal_force"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_normal_force</span></code></a>()</p></td>
<td><p>computes and returns the sum of all forces</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_relative_contact_area</span></code>()</p></td>
<td><p>compute and return the relative contact area:</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.dual_hessian_product" title="ContactMechanics.Systems.NonSmoothContactSystem.dual_hessian_product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dual_hessian_product</span></code></a>(pressure)</p></td>
<td><p>Returns the hessian product of the dual_objective function.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.dual_minimize_proxy" title="ContactMechanics.Systems.NonSmoothContactSystem.dual_minimize_proxy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dual_minimize_proxy</span></code></a>(offset[, init_force, ...])</p></td>
<td><p>Convenience function for DUAL minimisation (pixel forces as variables).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.dual_objective" title="ContactMechanics.Systems.NonSmoothContactSystem.dual_objective"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dual_objective</span></code></a>(offset[, gradient])</p></td>
<td><p>Objective function to handle dual objective, i.e. the Legendre transformation from displacements as variable to pressures (the Lagrange multiplier) as variable.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.evaluate" title="ContactMechanics.Systems.NonSmoothContactSystem.evaluate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate</span></code></a>(disp, offset[, pot, forces, logger])</p></td>
<td><p>Compute the energies and forces in the system for a given displacement field.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.evaluate_dual" title="ContactMechanics.Systems.NonSmoothContactSystem.evaluate_dual"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate_dual</span></code></a>(press, offset[, forces])</p></td>
<td><p>Computes the energies and forces in the system for a given pressure field.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.handles" title="ContactMechanics.Systems.NonSmoothContactSystem.handles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">handles</span></code></a>(substrate_type, surface_type, ...)</p></td>
<td><p>determines whether this class can handle the proposed system composition Keyword Arguments: substrate_type   -- instance of ElasticSubstrate subclass surface_type     --</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.hessian_product" title="ContactMechanics.Systems.NonSmoothContactSystem.hessian_product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hessian_product</span></code></a>(disp)</p></td>
<td><p>Computes the Hessian product for the objective function.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_proxy</span></code>()</p></td>
<td><p>subclasses may not be able to implement the full interface because they try to do something smart and internally compute a different system. They should declare to  to be proxies and provide a method called cls. deproxyfied() that returns the energy, force and displacement of the full problem based on its internal state. E.g at the end of an optimization, you could have: if system.is_proxy():     energy, force, disp = system.deproxyfied().</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.logger_input" title="ContactMechanics.Systems.NonSmoothContactSystem.logger_input"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logger_input</span></code></a>()</p></td>
<td><p>Describes the current state of the system (during minimization)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.minimize_proxy" title="ContactMechanics.Systems.NonSmoothContactSystem.minimize_proxy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minimize_proxy</span></code></a>([solver])</p></td>
<td><p>Convenience function.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.objective" title="ContactMechanics.Systems.NonSmoothContactSystem.objective"><code class="xref py py-obj docutils literal notranslate"><span class="pre">objective</span></code></a>(offset[, disp0, gradient, logger])</p></td>
<td><p>This helper method exposes a scipy.optimize-friendly interface to the evaluate() method.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.primal_hessian_product" title="ContactMechanics.Systems.NonSmoothContactSystem.primal_hessian_product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">primal_hessian_product</span></code></a>(gap)</p></td>
<td><p>Returns the hessian product of the primal_objective function.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.primal_minimize_proxy" title="ContactMechanics.Systems.NonSmoothContactSystem.primal_minimize_proxy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">primal_minimize_proxy</span></code></a>(offset[, init_gap, ...])</p></td>
<td><p>This function is a convenience function that simplifies the process of solving the primal minimisation problem where the gap is the variable.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.Systems.NonSmoothContactSystem.primal_objective" title="ContactMechanics.Systems.NonSmoothContactSystem.primal_objective"><code class="xref py py-obj docutils literal notranslate"><span class="pre">primal_objective</span></code></a>(offset[, gradient])</p></td>
<td><p>Solves the primal objective using gap as the variable.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape_minimisation_input</span></code>(in_array)</p></td>
<td><p>For minimisation of smart systems, the initial guess array (e.g. displacement) may have a non-intuitive shape and physical_sizes (The problem physical_sizes may be decreased, as for free, non-periodic systems, or increased as with augmented-lagrangian-type issues).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape_minimisation_output</span></code>(in_array)</p></td>
<td><p>For minimisation of smart systems, the output array (e.g. displacement) may have a non-intuitive shape and physical_sizes (The problem physical_sizes may be decreased, as for free, non-periodic systems, or increased as with augmented-lagrangian-type issues).</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.NonSmoothContactSystem.compute_contact_coordinates">
<span class="sig-name descname"><span class="pre">compute_contact_coordinates</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.NonSmoothContactSystem.compute_contact_coordinates" title="Link to this definition"></a></dt>
<dd><p>returns an array of all coordinates, where contact pressure is
repulsive. Useful for evaluating the number of contact islands etc.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.NonSmoothContactSystem.compute_nb_contact_pts">
<span class="sig-name descname"><span class="pre">compute_nb_contact_pts</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.NonSmoothContactSystem.compute_nb_contact_pts" title="Link to this definition"></a></dt>
<dd><p>compute and return the number of contact points. Note that this is of
no physical interest, as it is a purely numerical artefact</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.NonSmoothContactSystem.compute_normal_force">
<span class="sig-name descname"><span class="pre">compute_normal_force</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.NonSmoothContactSystem.compute_normal_force" title="Link to this definition"></a></dt>
<dd><p>computes and returns the sum of all forces</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.NonSmoothContactSystem.dual_hessian_product">
<span class="sig-name descname"><span class="pre">dual_hessian_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pressure</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.NonSmoothContactSystem.dual_hessian_product" title="Link to this definition"></a></dt>
<dd><p>Returns the hessian product of the dual_objective function.</p>
<p>The hessian product is the result of applying the hessian matrix (second derivatives of the objective function)
to the pressure vector. This is used in optimization algorithms that utilize second-order information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pressure</strong> (<em>array_like</em>) – The pressure vector to which the hessian matrix is applied.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>hessp</strong> – The hessian product, which is the result of applying the hessian matrix to the pressure vector.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.NonSmoothContactSystem.dual_minimize_proxy">
<span class="sig-name descname"><span class="pre">dual_minimize_proxy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">offset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_force</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ccg-without-restart'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.NonSmoothContactSystem.dual_minimize_proxy" title="Link to this definition"></a></dt>
<dd><p>Convenience function for DUAL minimisation (pixel forces as variables).
This function simplifies the process of solving the dual minimisation problem
by encapsulating the use of constrained minimisation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>offset</strong> (<em>float</em>) – Determines the indentation depth.</p></li>
<li><p><strong>init_force</strong> (<em>array_like</em><em>, </em><em>optional</em>) – Initial guess for the force. If not provided, it defaults to None.</p></li>
<li><p><strong>solver</strong> (<em>str</em><em>, </em><em>optional</em>) – The solver to be used for the minimisation. It can be one of
‘ccg-without-restart’, ‘ccg-with-restart’, or ‘l-bfgs-b’. If not provided,
it defaults to ‘ccg-without-restart’.</p></li>
<li><p><strong>gtol</strong> (<em>float</em><em>, </em><em>optional</em>) – The gradient tolerance for the solver. If not provided, it defaults to 1e-8.</p></li>
<li><p><strong>maxiter</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum number of iterations allowed for the solver to converge.
If not provided, it defaults to 1000.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>result</strong> – The result of the minimisation. It contains information about the optimisation
result, including the final gap, force, and displacement of the system at the solution.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>OptimizeResult</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.NonSmoothContactSystem.dual_objective">
<span class="sig-name descname"><span class="pre">dual_objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">offset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.NonSmoothContactSystem.dual_objective" title="Link to this definition"></a></dt>
<dd><p>Objective function to handle dual objective, i.e. the Legendre
transformation from displacements as variable to pressures
(the Lagrange multiplier) as variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>offset</strong> (<em>float</em>) – Constant value to add to the surface heights.</p></li>
<li><p><strong>gradient</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return the gradient in addition to the energy. Default is True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>energy</strong> (<em>float</em>) – Value of total energy.</p></li>
<li><p><strong>gradient</strong> (<em>array_like</em>) – Value of the gradient (array) or the value of gap (if gradient is True).</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The objective function is defined as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\min_\lambda \ q(\lambda) = \frac{1}{2}\lambda_i  K^{-1}_{ij} \lambda_j - \lambda_i h_i \\
\\
\nabla q = K^{-1}_{ij} \lambda_j - h_i \hspace{0.1cm}
\text{which is,} \\
\text{gap} = \text{displacement} - \text{height} \\\end{split}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.NonSmoothContactSystem.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">disp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logger</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.NonSmoothContactSystem.evaluate" title="Link to this definition"></a></dt>
<dd><p>Compute the energies and forces in the system for a given displacement field.</p>
<p>This method calculates the gap between the surface and the substrate by calling the <cite>compute_gap</cite> method.
It then computes the displacement field by calling the <cite>compute</cite> method of the substrate.</p>
<p>If potential energy is to be computed, it is set to the energy of the substrate. Otherwise, it is set to None.</p>
<p>If forces are to be computed, they are set to the force of the substrate. Otherwise, they are set to None.</p>
<p>If a logger is provided, it logs the current state of the system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>disp</strong> (<em>array_like</em>) – The displacement field for which the energies and forces are to be computed.</p></li>
<li><p><strong>offset</strong> (<em>float</em>) – The offset value to be used in the computation.</p></li>
<li><p><strong>pot</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, the potential energy in the system is also computed. Default is True.</p></li>
<li><p><strong>forces</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, the forces in the system are also computed. Default is False.</p></li>
<li><p><strong>logger</strong> (<a class="reference internal" href="ContactMechanics.Tools.html#ContactMechanics.Tools.Logger.Logger" title="ContactMechanics.Tools.Logger.Logger"><em>Logger</em></a><em>, </em><em>optional</em>) – Logger object to log information at each iteration. Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>energy</strong> (<em>float</em>) – Total energy of the system. If potential energy is not computed, it is None.</p></li>
<li><p><strong>force</strong> (<em>array_like</em>) – Forces in the system. If forces are not computed, they are None.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.NonSmoothContactSystem.evaluate_dual">
<span class="sig-name descname"><span class="pre">evaluate_dual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">press</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.NonSmoothContactSystem.evaluate_dual" title="Link to this definition"></a></dt>
<dd><p>Computes the energies and forces in the system for a given pressure field.</p>
<p>This method calculates the displacement field corresponding to the given pressure field
by calling the <cite>evaluate_disp</cite> method of the substrate. The negative of the pressure field
is passed as an argument to the <cite>evaluate_disp</cite> method.</p>
<p>If forces are to be computed, the gradient is calculated as the difference between the displacement
and the sum of the surface heights and the offset. Otherwise, the gradient is set to None.</p>
<p>The energy is then computed as half the sum of the product of the pressure and displacement fields,
minus the sum of the product of the pressure and the sum of the surface heights and the offset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>press</strong> (<em>array_like</em>) – The pressure field for which the displacement field is to be computed.</p></li>
<li><p><strong>offset</strong> (<em>float</em>) – The offset value to be used in the computation.</p></li>
<li><p><strong>forces</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, the forces in the system are also computed. Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>energy</strong> (<em>float</em>) – Total energy of the system.</p></li>
<li><p><strong>gradient</strong> (<em>array_like</em>) – Gradient, which is the difference between the displacement and the sum of the
surface heights and the offset. If forces are not computed, the gradient is None.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.NonSmoothContactSystem.handles">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">handles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">substrate_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_domain_decomposed</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.NonSmoothContactSystem.handles" title="Link to this definition"></a></dt>
<dd><p>determines whether this class can handle the proposed system
composition
Keyword Arguments:
substrate_type   – instance of ElasticSubstrate subclass
surface_type     –</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.NonSmoothContactSystem.hessian_product">
<span class="sig-name descname"><span class="pre">hessian_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">disp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.NonSmoothContactSystem.hessian_product" title="Link to this definition"></a></dt>
<dd><p>Computes the Hessian product for the objective function.</p>
<p>This method calculates the Hessian product by calling the <cite>primal_hessian_product</cite> method.
The Hessian product is the result of applying the Hessian matrix (second derivatives of the objective function)
to the displacement vector. This is used in optimization algorithms that utilize second-order information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>disp</strong> (<em>array_like</em>) – The displacement vector to which the Hessian matrix is applied. It can be an array of shape
nb_subdomain_grid_pts or a flattened version of it.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The Hessian product, which is the result of applying the Hessian matrix to the displacement vector.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.NonSmoothContactSystem.logger_input">
<span class="sig-name descname"><span class="pre">logger_input</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.NonSmoothContactSystem.logger_input" title="Link to this definition"></a></dt>
<dd><p>Describes the current state of the system (during minimization)</p>
<p>Output is suited to be passed to ContactMechanics.Tools.Logger.Logger</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>headers</strong> (<em>list of strings</em>)</p></li>
<li><p><strong>values</strong> (<em>list</em>)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.NonSmoothContactSystem.minimize_proxy">
<span class="sig-name descname"><span class="pre">minimize_proxy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solver=&lt;function</span> <span class="pre">doi.__call__.&lt;locals&gt;.func_with_doi&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.NonSmoothContactSystem.minimize_proxy" title="Link to this definition"></a></dt>
<dd><p>Convenience function. Eliminates boilerplate code for most minimisation
problems by encapsulating the use of constrained minimisation.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ContactMechanics.Systems.NonSmoothContactSystem.nb_grid_pts">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nb_grid_pts</span></span><a class="headerlink" href="#ContactMechanics.Systems.NonSmoothContactSystem.nb_grid_pts" title="Link to this definition"></a></dt>
<dd><p>For systems, nb_grid_pts can become non-trivial</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.NonSmoothContactSystem.objective">
<span class="sig-name descname"><span class="pre">objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">offset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disp0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logger</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.NonSmoothContactSystem.objective" title="Link to this definition"></a></dt>
<dd><p>This helper method exposes a scipy.optimize-friendly interface to the
evaluate() method. It is used for optimization purposes and ensures
that the shape of displacement is maintained. It also allows setting the offset and
‘forces’ flag without using scipy’s argument passing interface.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>offset</strong> (<em>float</em>) – Determines the indentation depth.</p></li>
<li><p><strong>disp0</strong> (<em>array_like</em><em>, </em><em>optional</em>) – Unused variable, present only for interface compatibility
with inheriting classes. Default is None.</p></li>
<li><p><strong>gradient</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, the gradient is supposed to be used. Default is False.</p></li>
<li><p><strong>logger</strong> (<a class="reference internal" href="ContactMechanics.Tools.html#ContactMechanics.Tools.Logger.Logger" title="ContactMechanics.Tools.Logger.Logger"><em>Logger</em></a><em>, </em><em>optional</em>) – Logger object to log information at each iteration. Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>fun</strong> – A function of only displacement. If gradient is True, this function returns
the energy and the negative of the force when called with displacement.
If gradient is False, it returns only the energy.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>function</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.NonSmoothContactSystem.primal_hessian_product">
<span class="sig-name descname"><span class="pre">primal_hessian_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gap</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.NonSmoothContactSystem.primal_hessian_product" title="Link to this definition"></a></dt>
<dd><p>Returns the hessian product of the primal_objective function.</p>
<p>The hessian product is the result of applying the hessian matrix (second derivatives of the objective function)
to the gap vector. This is used in optimization algorithms that utilize second-order information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>gap</strong> (<em>array_like</em>) – The gap vector to which the hessian matrix is applied.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>hessp</strong> – The hessian product, which is the result of applying the hessian matrix to the gap vector.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The hessian product is computed as the negative of the force evaluated at the reshaped gap vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.NonSmoothContactSystem.primal_minimize_proxy">
<span class="sig-name descname"><span class="pre">primal_minimize_proxy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">offset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_gap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ccg-without-restart'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.NonSmoothContactSystem.primal_minimize_proxy" title="Link to this definition"></a></dt>
<dd><p>This function is a convenience function that simplifies the process of
solving the primal minimisation problem where the gap is the variable.
It does this by encapsulating the use of constrained minimisation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>offset</strong> (<em>float</em>) – This parameter determines the indentation depth.</p></li>
<li><p><strong>init_gap</strong> (<em>array_like</em><em>, </em><em>optional</em>) – This is the initial guess for the gap. If not provided, it defaults to None.</p></li>
<li><p><strong>solver</strong> (<em>str</em><em>, </em><em>optional</em>) – This is the solver to be used for the minimisation. It can be one of
‘ccg-without-restart’, ‘ccg-with-restart’, or ‘l-bfgs-b’. If not provided,
it defaults to ‘ccg-without-restart’.</p></li>
<li><p><strong>gtol</strong> (<em>float</em><em>, </em><em>optional</em>) – This is the gradient tolerance for the solver. If not provided, it defaults to 1e-8.</p></li>
<li><p><strong>maxiter</strong> (<em>int</em><em>, </em><em>optional</em>) – This is the maximum number of iterations allowed for the solver to converge.
If not provided, it defaults to 1000.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>result</strong> – The result of the minimisation. It contains information about the optimisation
result, including the final gap, force, and displacement of the system at the solution.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>OptimizeResult</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.NonSmoothContactSystem.primal_objective">
<span class="sig-name descname"><span class="pre">primal_objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">offset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.NonSmoothContactSystem.primal_objective" title="Link to this definition"></a></dt>
<dd><p>Solves the primal objective using gap as the variable. This function can be fed directly to standard solvers
such as scipy solvers etc. and returns the elastic energy and its gradient (negative of the forces) as a
function of the gap.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>offset</strong> (<em>float</em>) – Constant value to add to the surface heights.</p></li>
<li><p><strong>gradient</strong> (<em>bool</em><em>, </em><em>optional</em>) – Return gradient in addition to the energy. Default is True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>energy</strong> (<em>float</em>) – Value of total energy.</p></li>
<li><p><strong>force</strong> (<em>array_like</em>) – Value of the forces per surface node (only if gradient is True).</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The objective function is defined as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\min_u f(u) = 1/2 u_i K_{ij} u_j \\
\\
\nabla f = K_{ij} u_j \ \ \ \text{which is the Force.} \\\end{split}\]</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ContactMechanics.Systems.SystemBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ContactMechanics.Systems.</span></span><span class="sig-name descname"><span class="pre">SystemBase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">substrate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.SystemBase" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base class for contact systems</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.nb_grid_pts" title="ContactMechanics.Systems.SystemBase.nb_grid_pts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nb_grid_pts</span></code></a></dt><dd><p>For systems, nb_grid_pts can become non-trivial</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.callback" title="ContactMechanics.Systems.SystemBase.callback"><code class="xref py py-obj docutils literal notranslate"><span class="pre">callback</span></code></a>([force])</p></td>
<td><p>Simple callback function that can be handed over to scipy's minimize to get updates during minimisation Parameters: force -- (default False) whether to include the norm of the force          vector in the update message</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.compute_contact_area" title="ContactMechanics.Systems.SystemBase.compute_contact_area"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_contact_area</span></code></a>()</p></td>
<td><p>computes and returns the total contact area</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.compute_gap" title="ContactMechanics.Systems.SystemBase.compute_gap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_gap</span></code></a>(disp, offset, *profile_args, ...)</p></td>
<td><p>evaluate the gap between surface and substrate.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.compute_nb_contact_pts" title="ContactMechanics.Systems.SystemBase.compute_nb_contact_pts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_nb_contact_pts</span></code></a>()</p></td>
<td><p>compute and return the number of contact points.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.compute_normal_force" title="ContactMechanics.Systems.SystemBase.compute_normal_force"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_normal_force</span></code></a>()</p></td>
<td><p>evaluates and returns the normal force between substrate and surface</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.compute_relative_contact_area" title="ContactMechanics.Systems.SystemBase.compute_relative_contact_area"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_relative_contact_area</span></code></a>()</p></td>
<td><p>compute and return the relative contact area:</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.evaluate" title="ContactMechanics.Systems.SystemBase.evaluate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate</span></code></a>(disp, offset[, pot, forces])</p></td>
<td><p>Compute the energies and forces in the system for a given displacement field</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.handles" title="ContactMechanics.Systems.SystemBase.handles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">handles</span></code></a>(substrate_type, surface_type, ...)</p></td>
<td><p>returns whether this class (in practice a subclass) handles this combination of types Keyword Arguments: substrate_type   -- self-explanatory surface_type     -- self-explanatory is_domain_decomposed: some systems cannot handle parallel computation</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.is_proxy" title="ContactMechanics.Systems.SystemBase.is_proxy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_proxy</span></code></a>()</p></td>
<td><p>subclasses may not be able to implement the full interface because they try to do something smart and internally compute a different system. They should declare to  to be proxies and provide a method called cls. deproxyfied() that returns the energy, force and displacement of the full problem based on its internal state. E.g at the end of an optimization, you could have: if system.is_proxy():     energy, force, disp = system.deproxyfied().</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.minimize_proxy" title="ContactMechanics.Systems.SystemBase.minimize_proxy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minimize_proxy</span></code></a>([offset, ...])</p></td>
<td><p>Convenience function.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.objective" title="ContactMechanics.Systems.SystemBase.objective"><code class="xref py py-obj docutils literal notranslate"><span class="pre">objective</span></code></a>(offset[, disp0, gradient, logger])</p></td>
<td><p>This helper method exposes a scipy.optimize-friendly interface to the evaluate() method. Use this for optimization purposes, it makes sure that the shape of disp is maintained and lets you set the offset and 'forces' flag without using scipy's cumbersome argument passing interface. Returns a function of only disp Keyword Arguments: offset     -- determines indentation depth disp0      -- preexisting displacement. influences e.g., the               physical_sizes of the proxy system in some 'smart'               system subclasses gradient   -- (default False) whether the gradient is supposed to be               used logger     -- (default None) log information at every iteration.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.shape_minimisation_input" title="ContactMechanics.Systems.SystemBase.shape_minimisation_input"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape_minimisation_input</span></code></a>(in_array)</p></td>
<td><p>For minimisation of smart systems, the initial guess array (e.g. displacement) may have a non-intuitive shape and physical_sizes (The problem physical_sizes may be decreased, as for free, non-periodic systems, or increased as with augmented-lagrangian-type issues).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ContactMechanics.Systems.SystemBase.shape_minimisation_output" title="ContactMechanics.Systems.SystemBase.shape_minimisation_output"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape_minimisation_output</span></code></a>(in_array)</p></td>
<td><p>For minimisation of smart systems, the output array (e.g. displacement) may have a non-intuitive shape and physical_sizes (The problem physical_sizes may be decreased, as for free, non-periodic systems, or increased as with augmented-lagrangian-type issues).</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.SystemBase.callback">
<span class="sig-name descname"><span class="pre">callback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">force</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.SystemBase.callback" title="Link to this definition"></a></dt>
<dd><p>Simple callback function that can be handed over to scipy’s minimize to
get updates during minimisation
Parameters:
force – (default False) whether to include the norm of the force</p>
<blockquote>
<div><p>vector in the update message</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.SystemBase.compute_contact_area">
<span class="sig-name descname"><span class="pre">compute_contact_area</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.SystemBase.compute_contact_area" title="Link to this definition"></a></dt>
<dd><p>computes and returns the total contact area</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.SystemBase.compute_gap">
<span class="sig-name descname"><span class="pre">compute_gap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">disp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">profile_args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">profile_kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.SystemBase.compute_gap" title="Link to this definition"></a></dt>
<dd><p>evaluate the gap between surface and substrate. Convention is that
non-penetrating contact has gap &gt;= 0</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.SystemBase.compute_nb_contact_pts">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">compute_nb_contact_pts</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.SystemBase.compute_nb_contact_pts" title="Link to this definition"></a></dt>
<dd><p>compute and return the number of contact points. Note that this is of
no physical interest, as it is a purely numerical artefact</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.SystemBase.compute_normal_force">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">compute_normal_force</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.SystemBase.compute_normal_force" title="Link to this definition"></a></dt>
<dd><p>evaluates and returns the normal force between substrate and surface</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.SystemBase.compute_relative_contact_area">
<span class="sig-name descname"><span class="pre">compute_relative_contact_area</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.SystemBase.compute_relative_contact_area" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>compute and return the relative contact area:</dt><dd><p>A</p>
</dd>
<dt>Aᵣ = ──</dt><dd><p>A₀</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.SystemBase.evaluate">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">disp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.SystemBase.evaluate" title="Link to this definition"></a></dt>
<dd><p>Compute the energies and forces in the system for a given displacement
field</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.SystemBase.handles">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">handles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">substrate_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_domain_decomposed</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.SystemBase.handles" title="Link to this definition"></a></dt>
<dd><p>returns whether this class (in practice a subclass) handles this
combination of types
Keyword Arguments:
substrate_type   – self-explanatory
surface_type     – self-explanatory
is_domain_decomposed: some systems cannot handle parallel computation</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.SystemBase.is_proxy">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_proxy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.SystemBase.is_proxy" title="Link to this definition"></a></dt>
<dd><p>subclasses may not be able to implement the full interface because they
try to do something smart and internally compute a different system.
They should declare to  to be proxies and provide a method called cls.
deproxyfied() that returns the energy, force and displacement of the
full problem based on its internal state. E.g at the end of an
optimization, you could have:
if system.is_proxy():</p>
<blockquote>
<div><p>energy, force, disp = system.deproxyfied()</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.SystemBase.minimize_proxy">
<span class="sig-name descname"><span class="pre">minimize_proxy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_displacements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L-BFGS-B'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ubounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logger</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.SystemBase.minimize_proxy" title="Link to this definition"></a></dt>
<dd><p>Convenience function. Eliminates boilerplate code for most minimisation
problems by encapsulating the use of scipy.minimize for common default
options. In the case of smart proxy systems, this may also encapsulate
things like dynamics computation of safety margins, extrapolation of
results onto the proxied system, etc.</p>
<p>Parameters:
offset : float</p>
<blockquote>
<div><p>determines indentation depth</p>
</div></blockquote>
<dl>
<dt>initial_displacements<span class="classifier">(default zero)</span></dt><dd><p>initial guess for displacement field. If
not chosen appropriately, results may be unreliable.</p>
</dd>
<dt>method<span class="classifier">string or callable</span></dt><dd><p>(defaults to L-BFGS-B, see scipy documentation).
Be sure to choose method that can handle high-dimensional
parameter spaces.</p>
</dd>
<dt>options<span class="classifier">dict</span></dt><dd><p>(default None)
options to be passed to the minimizer method</p>
</dd>
<dt>gradient<span class="classifier">bool</span></dt><dd><p>(default True)
whether to use the gradient or not</p>
</dd>
<dt>lbounds<span class="classifier">array of shape substrate.subdomain_nb_grid_pts or</span></dt><dd><blockquote>
<div><p>substrate.topography_subdomain_nb_grid_pts or “auto”</p>
</div></blockquote>
<dl class="simple">
<dt>(default None)</dt><dd><p>nodal ceiling/floor</p>
</dd>
</dl>
</dd>
<dt>ubounds<span class="classifier">array of shape substrate.subdomain_nb_grid_pts or</span></dt><dd><blockquote>
<div><p>substrate.topography_subdomain_nb_grid_pts</p>
</div></blockquote>
<p>(default None)</p>
</dd>
<dt>tol<span class="classifier">float</span></dt><dd><p>(default None)
tolerance for termination. For detailed control, use
solver-specific options.</p>
</dd>
<dt>callback<span class="classifier">callable</span></dt><dd><p>(default None)
callback function to be at each iteration</p>
<blockquote>
<div><p>as callback(disp_k) where disp_k is the current
displacement vector. Instead of a callable, it can be set
to ‘True’, in which case the system’s default callback
function is called.</p>
</div></blockquote>
</dd>
<dt>logger :</dt><dd><p>(default None)
log information at every objective evaluation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ContactMechanics.Systems.SystemBase.nb_grid_pts">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nb_grid_pts</span></span><a class="headerlink" href="#ContactMechanics.Systems.SystemBase.nb_grid_pts" title="Link to this definition"></a></dt>
<dd><p>For systems, nb_grid_pts can become non-trivial</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.SystemBase.objective">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">offset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disp0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logger</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.SystemBase.objective" title="Link to this definition"></a></dt>
<dd><p>This helper method exposes a scipy.optimize-friendly interface to the
evaluate() method. Use this for optimization purposes, it makes sure
that the shape of disp is maintained and lets you set the offset and
‘forces’ flag without using scipy’s cumbersome argument passing
interface. Returns a function of only disp
Keyword Arguments:
offset     – determines indentation depth
disp0      – preexisting displacement. influences e.g., the</p>
<blockquote>
<div><p>physical_sizes of the proxy system in some ‘smart’
system subclasses</p>
</div></blockquote>
<dl class="simple">
<dt>gradient   – (default False) whether the gradient is supposed to be</dt><dd><p>used</p>
</dd>
</dl>
<p>logger     – (default None) log information at every iteration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.SystemBase.shape_minimisation_input">
<span class="sig-name descname"><span class="pre">shape_minimisation_input</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.SystemBase.shape_minimisation_input" title="Link to this definition"></a></dt>
<dd><p>For minimisation of smart systems, the initial guess array (e.g.
displacement) may have a non-intuitive shape and physical_sizes (The
problem physical_sizes may be decreased, as for free, non-periodic
systems, or increased as with augmented-lagrangian-type issues). Use
the output of this function as argument x0 for scipy minimisation
functions. Also, if you initial guess has a shape that makes no sense,
this will tell you before you get caught in debugging scipy-code</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ContactMechanics.Systems.SystemBase.shape_minimisation_output">
<span class="sig-name descname"><span class="pre">shape_minimisation_output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ContactMechanics.Systems.SystemBase.shape_minimisation_output" title="Link to this definition"></a></dt>
<dd><p>For minimisation of smart systems, the output array (e.g.
displacement) may have a non-intuitive shape and physical_sizes (The
problem physical_sizes may be decreased, as for free, non-periodic
systems, or increased as with augmented-lagrangian-type issues). Use
this function to get the array shape you expect to have</p>
<p>Arguments:
in_array – array with the initial guess. has the intuitive shape you</p>
<blockquote>
<div><p>think it has</p>
</div></blockquote>
</dd></dl>

</dd></dl>

</section>
<section id="contactmechanics-test-surface-topography-module">
<h2>ContactMechanics.test_surface_topography module<a class="headerlink" href="#contactmechanics-test-surface-topography-module" title="Link to this heading"></a></h2>
</section>
<section id="module-ContactMechanics">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-ContactMechanics" title="Link to this heading"></a></h2>
<p>Defines all solid mechanics model used in ContactMechanics</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../contributing.html" class="btn btn-neutral float-left" title="Contributing to ContactMechanics" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ContactMechanics.CommandLineInterface.html" class="btn btn-neutral float-right" title="ContactMechanics.CommandLineInterface package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015-2020 The Authors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>